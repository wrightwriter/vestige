// Generated with Shader Minifier 1.4.0 (https://github.com/laurentlb/Shader_Minifier/)
#ifndef SHADER_INCLUDES_H_
# define SHADER_INCLUDES_H_

static const char* music_comp =
 "#version 460 core\n"
 "layout(local_size_x=256,local_size_y=1,local_size_z=1)in;\n"
 "layout(std430,binding=0) buffer A{vec2 f[];};\n"
 "const float s=acos(-1.),v=2.*s;\n"
 "uvec3 t(uvec3 f)\n"
 "{\n"
   "f=f*1664525u+1013904223u;\n"
   "f.x+=f.y*f.z;\n"
   "f.y+=f.z*f.x;\n"
   "f.z+=f.x*f.y;\n"
   "f^=f>>16u;\n"
   "f.x+=f.y*f.z;\n"
   "f.y+=f.z*f.x;\n"
   "f.z+=f.x*f.y;\n"
   "return f;\n"
 "}\n"
 "vec3 p(vec3 f)\n"
 "{\n"
   "uvec3 v=t(floatBitsToUint(f*125.12));\n"
   "return vec3(v)/float(-1u);\n"
 "}\n"
 "vec3 n(vec3 f)\n"
 "{\n"
   "f+=12.124;\n"
   "uvec3 v=floatBitsToUint(f);\n"
   "v=(v>>16u^v.yzx)*1111111111u;\n"
   "v=(v>>16u^v.yzx)*1111111111u;\n"
   "v=(v>>16u^v.yzx)*1111111111u;\n"
   "return vec3(v)/float(-1u);\n"
 "}\n"
 "vec3 d(float f)\n"
 "{\n"
   "return n(vec3(f));\n"
 "}\n"
 "float r(float f)\n"
 "{\n"
   "return 440.*pow(2.,f/12.);\n"
 "}\n"
 "mat2 m(float f)\n"
 "{\n"
   "return mat2(cos(f),-sin(f),sin(f),cos(f));\n"
 "}\n"
 "vec3 d(vec3 f,float v,float u)\n"
 "{\n"
   "vec4 T=vec4(0);\n"
   "for(int i=0;i++<5;)\n"
     "f.yz*=m(4.5),f.xy*=m(1.5),f+=sin(f.zxy),T=(T+vec4(cross(cos(f),sin(f.yzx)),1))/v,f*=u;\n"
   "return T.xyz/T.w;\n"
 "}\n"
 "void main()\n"
 "{\n"
   "uint T=gl_GlobalInvocationID.x;\n"
   "vec2 i=vec2(0);\n"
   "float s=float(T)/44100.,l=s,x=float(T%264600)/44100.;\n"
   "if(s>280.)\n"
     "{\n"
       "float f=exp(-mod(s,4.)*10.);\n"
       "i+=f*sin(x*30.*v+sin(x*30.*v*10.)*f*.2)*4.;\n"
     "}\n"
   "float u=1.;\n"
   "if(s>250.)\n"
     "{\n"
       "float f=2.+sin(s)*2e-4;\n"
       "s*=4.;\n"
       "float v=floor(-s/f),m=mod(-s,f);\n"
       "s=m+d(v).x*4.+(s/4.-260.)*.6;\n"
       "u=smoothstep(0.,f*.04,m)*smoothstep(f,f*.98,m)*4.;\n"
       "x*=.25+.25*float(l>260.)+d(v).z*.02;\n"
     "}\n"
   "else\n"
     " s=mix(s,0.,pow(clamp((s-230.)*.04,0.,1.),2.));\n"
   "float z=4e2;\n"
   "float[4] c=float[](-12.,1.,3.,10.);\n"
   "z=1e3;\n"
   "\n#if false\n"
   "\n#endif\n"
   "{\n"
     "float[7] R=float[](0.,1.,3.,5.,7.,8.,10.);\n"
     "for(float f=10.;f++<2435.+min(s,0);)\n"
       "{\n"
         "float T=60./140.*4.,z=s;\n"
         "z-=T*floor(d(f).z*4.);\n"
         "z-=T*pow(d(f).y,1.2)*(1.+6.*smoothstep(10.,20.,s));\n"
         "float u=floor(z/(T*4.)),y=smoothstep(0.,4.,u)*.5;\n"
         "z=mod(z,T*4.);\n"
         "y=r(R[int(f+u)%R.length()]-12.+12.*float(d(f+u).y<.4*y)+12.*float(d(f+u).x<.4*y)-12.*float(d(f+u).z<.5*y)-12.*float(d(f*1.5+u).z<.5*y)-12.*float(d(f*1.25+u).z<.2*y));\n"
         "float c=2.+pow(d(f+u).x,2.5)*20.;\n"
         "for(float l=0.;l<c+min(s,0);l++)\n"
           "{\n"
             "float r=1.+smoothstep(0.,4.,u)*2.*exp(-mod(s,1.))*smoothstep(0.,.004,mod(s,1.)),p=pow(d(f+l*1.5+u).x,2.+.5*smoothstep(5e2,2e3,y));\n"
             "y*=1.+floor(p*r);\n"
             "y+=(d(l+f*1.4).x-.5)*20.*smoothstep(0.,30.,s);\n"
             "r=exp(-z*(7.-6.*smoothstep(2e3,8e2,y))*.7)*smoothstep(T*2.,0.,z)*smoothstep(0.,.002,z)*smoothstep(7e3,8e2,y);\n"
             "vec2 R=vec2(sin(v*y*x+sin(d(f*2.4+u).x*15.*x)*4.*smoothstep(10.,20.,s)+sin(v*y*x*2.)*r*r*r*.6*smoothstep(20.,60.,s)))*m(f);\n"
             "i+=r*R/2425./c*30.3*(float(s<60.)+smoothstep(160.,180.,s)*4.);\n"
           "}\n"
       "}\n"
   "}\n"
   "z=4e2;\n"
   "for(float f=0.;++f<z;)\n"
     "{\n"
       "float T=s-pow(smoothstep(0.,1.,p(vec3(f)).x),1.2)*(.2+3.*p(vec3(f)).y);\n"
       "if(f<2.)\n"
         "T=s;\n"
       "float[4] m=float[](c[0],c[1],c[2],c[3]);\n"
       "if(mod(T,8)<1.)\n"
         "for(int f=0;f<4;f++)\n"
           "m[f]+=7;\n"
       "float y=mix(10.,.5+sin(T*.5)*2./T*smoothstep(10.,20.,s),smoothstep(0.,60.,s)),u=floor(T/y),a=mod(T,y);\n"
       "y=m[int(mod(u,4.))]-12.*float(p(vec3(u)).x<.2)+12.*float(p(vec3(u)).z<.2);\n"
       "y=r(y+12.*float(T>60.)-12.-12.);\n"
       "y-=12.*float(p(vec3(u)).x<.2);\n"
       "u=smoothstep(0.,.004,a)*exp(-a*10.);\n"
       "T=(2.+10.*smoothstep(60.,1e2,s))*(u*u*sin(x*y*v));\n"
       "if(f<2.)\n"
         "i+=u*sin(x*y*v+T)*.3;\n"
       "else\n"
         "{\n"
           "float s=a*0.;\n"
           "i+=7.*u*sin(x*y*v+T+d(vec3(vec2(sin(s),cos(s)),f),1.,1.).xy*30.)/z;\n"
         "}\n"
     "}\n"
   "i*=.14;\n"
   "z=44.-10.*smoothstep(30.,50.,s);\n"
   "for(int f=0;f<4;f++)\n"
     "for(float T=0.;++T<z;)\n"
       "{\n"
         "float u=s,y=r(c[f]+12.*float(p(vec3(T)).z<.1)+12.*float(p(vec3(T)*1e2).x<.1)-12.*float(p(vec3(T)).x<.5)-12.);\n"
         "y+=12.*float(p(vec3(T)).z<.1);\n"
         "y-=p(vec3(T)*4.).x*smoothstep(120.,144.,s)*1e2;\n"
         "u=v*y*u+sin(T*4.+float(f)+s*.3)*14.;\n"
         "vec2 R=d(vec3(fract(u/v))*vec3(2,-3,-8),.5,.4).xy*m(T*.2)-d(vec3(vec2(sin(u),cos(u)),T*.1+float(f)),.5,smoothstep(120.,144.,s)*2.).xy*m(-T*.5);\n"
         "i+=R/z*.15*smoothstep(60.,1e2,s);\n"
       "}\n"
   "vec2 y=vec2(0);\n"
   "z=4.;\n"
   "for(float f=0.;++f<z;)\n"
     "{\n"
       "float T=s,u=.5+sin(T*.5)*2./T,i=mod(T,u),p=r(c[0]-12.-12.-12.),m=smoothstep(160.,180.,s);\n"
       "i=smoothstep(0.,.04,i)*exp(-i*(20.-15.*m))*smoothstep(u,0.,i);\n"
       "u=i*i*sin(x*(p*(1.+m*10.*floor(d(floor(T/u)).x*10.)))*v)*(1.-.9*m);\n"
       "i*=smoothstep(1e2,110.,s);\n"
       "if(s>60&&s<70.)\n"
         "i=exp(-s+60.)*4.;\n"
       "if(s>80&&T<1e2)\n"
         "i=exp(-mod(s,4.))*.4;\n"
       "i*=1.+0.*smoothstep(140.,150.,s);\n"
       "y+=i*sin(x*p*v+u)/z*2.;\n"
     "}\n"
   "i=tanh((i+y)*1.2);\n"
   "f[T+3000000]=i*u;\n"
 "}";

static const char* post_frag =
 "#version 460 core\n"
 "layout(location=0) uniform int F;\n"
 "layout(location=1) uniform float T;\n"
 "layout(location=2) uniform vec2 R;\n"
 "layout(std430,binding=0) coherent buffer Aa{uint i[];};\n"
 "out vec4 C;\n"
 "uint u=111425u;\n"
 "uint c(uint f)\n"
 "{\n"
   "f=(f^f>>16)*2146121005u;\n"
   "f=(f^f>>15)*2221713035u;\n"
   "return f^f>>16;\n"
 "}\n"
 "float l(float f)\n"
 "{\n"
   "return float(c(uint(f)))/float(-1u);\n"
 "}\n"
 "float c()\n"
 "{\n"
   "uint f=c(u);\n"
   "u=f;\n"
   "return float(f)/float(-1u);\n"
 "}\n"
 "uint w(ivec2 f)\n"
 "{\n"
   "return(f.x+uint(R.x)*f.y+uint(R.x*R.y))%uint(R.x*R.y);\n"
 "}\n"
 "vec3[4] y=vec3[](vec3(1),vec3(1,0,1),vec3(1,1,.1),vec3(.5,1,1)*1.5);\n"
 "vec3 e(float f)\n"
 "{\n"
   "int T=int(f*float(4));\n"
   "f=smoothstep(0.,1.,fract(f*float(4)));\n"
   "return mix(y[T],y[(T+1)%4],f);\n"
 "}\n"
 "void main()\n"
 "{\n"
   "u=uint(gl_FragCoord.x+gl_FragCoord.y*1111);\n"
   "c();\n"
   "float f=smoothstep(250.,250.1,T),s=smoothstep(280.,280.1,T),y=exp(-mod(T,.5+sin(T*.5)*2./T)*40.);\n"
   "y=.03+.1*smoothstep(90.,190.,T)-f+4.*s*smoothstep(4.,0.,mod(T,4.));\n"
   "float v=smoothstep(0.,50.,T)*pow(l(floor(T)),2)*(1.-f+s);\n"
   "if(T>80&&T<1e2)\n"
     "v=1e2*smoothstep(1.,0.,mod(T,4.));\n"
   "uint m=w(ivec2(gl_FragCoord.xy));\n"
   "vec3 z=vec3(i[m])*1e-4,a=e(mod(z.x*115.,1.));\n"
   "z/=1.+z;\n"
   "z=l(floor(T*.8))<.7?\n"
     "1.-z:\n"
     "pow(abs(pow(step(z,vec3(.5)),vec3(.02))),vec3(.02));\n"
   "if(T>60&&T<65.)\n"
     "z=1.-z;\n"
   "if(abs(z.x-.1)<y)\n"
     "z-=a;\n"
   "C=vec4(pow(abs(z),vec3(4.400000044)),1);\n"
   "if(mod(T,9.-s*5.)<1.)\n"
     "i[m]=0;\n"
   "else if(z.x<v)\n"
     "{\n"
       "ivec2 f=-ivec2(0,4);\n"
       "f*=(int(c()<z.x*1111.)*2-1)*(1+5*int(l(floor(T))));\n"
       "f=f*(int(l(floor(T)*124.)*2.)*2-1)*(1+int(s*smoothstep(3.,0.,mod(T,4.))*20.));\n"
       "if(T>122)\n"
         "f=ivec2(f.y,f.x);\n"
       "if(T>316&&c()>.5)\n"
         "f-=f;\n"
       "i[m]=i[w(ivec2(gl_FragCoord.xy)+f)];\n"
     "}\n"
   "else\n"
     " i[m]=0;\n"
   "if(f>.1)\n"
     "C=1.-C;\n"
   "if(T>350.)\n"
     "C=vec4(dot(C,C)<.5);\n"
 "}";

static const char* render_comp =
 "#version 460 core\n"
 "layout(local_size_x=256,local_size_y=1,local_size_z=1)in;\n"
 "layout(std430,binding=0) coherent buffer Aaa{uint z[];};\n"
 "layout(location=1) uniform float Tt;\n"
 "layout(location=2) uniform vec2 R;\n"
 "float x;\n"
 "const float a=acos(-1.),b=acos(-1.)*2.;\n"
 "uint g=111425u;\n"
 "uint c(uint f)\n"
 "{\n"
   "f=(f^f>>16)*2146121005u;\n"
   "f=(f^f>>15)*2221713035u;\n"
   "return f^f>>16;\n"
 "}\n"
 "float l(float f)\n"
 "{\n"
   "return float(c(uint(f)))/float(-1u);\n"
 "}\n"
 "float c()\n"
 "{\n"
   "uint f=c(g);\n"
   "g=f;\n"
   "return float(f)/float(-1u);\n"
 "}\n"
 "vec3 A(float f)\n"
 "{\n"
   "return vec3(l(f),l(f),l(f));\n"
 "}\n"
 "vec2 A()\n"
 "{\n"
   "vec2 f=vec2(c(),c());\n"
   "return vec2(sin(f.x*b),cos(f.x*b))*sqrt(f.y);\n"
 "}\n"
 "#define pmod(p,amt)(mod((p+amt*0.5),amt)-amt*0.5)\n"
 "mat2 m(float f)\n"
 "{\n"
   "return mat2(cos(f),-sin(f),sin(f),cos(f));\n"
 "}\n"
 "float d()\n"
 "{\n"
   "return float(c()<.5)*2.-1.;\n"
 "}\n"
 "void main()\n"
 "{\n"
   "uint f=uint(gl_GlobalInvocationID.x);\n"
   "g=f+1111111u;\n"
   "x=Tt;\n"
   "x=mod(x,360.);\n"
   "float s=smoothstep(250.,250.1,x),u=.5+sin(x*.5)*2./x;\n"
   "u=exp(-mod(x,u)*4.);\n"
   "u=(.4*smoothstep(45.,15.,x)-.4*smoothstep(160.,180.,x)*u+.4*smoothstep(314.,320.,x)*u)*(1.-s);\n"
   "float T=2e2*smoothstep(25.,65.,x);\n"
   "bool v=mod(x,8.)<2.,y=l(floor(x+1555))>.5;\n"
   "float i=1.+.02*smoothstep(90.,150.,x),p=.2+.4*smoothstep(60.,80.,x)-.4*smoothstep(90.,110.,x)-.4*smoothstep(120.,160.,x),e=1.-smoothstep(90.,110.,x)+smoothstep(90.,150.,x);\n"
   "if(x<10.)\n"
     "v=false;\n"
   "int n=30+int(T);\n"
   "T=x;\n"
   "T+=sin(T)*.8;\n"
   "vec3 r=vec3(0);\n"
   "float C=sin(x*9.)*4.*smoothstep(280.,280.1,x);\n"
   "vec2 b=vec2(100,0)*s*(1.-smoothstep(314.,320.,x));\n"
   "vec3 D=vec3(c(),c(),c()),t=A(floor(x)),w=(D.y<.5?\n"
     "vec3(0,-1,0):\n"
     "vec3(1,0,0))*i;\n"
   "t*=e;\n"
   "for(int i=0;i<n;i++)\n"
     "{\n"
       "float s=c();\n"
       "r+=w*(.002*(1.+20.*t.x)+sin(float(f.x))*.01);\n"
       "if(D.y<.5)\n"
         "{\n"
           "if(i%10==0)\n"
             "w+=r;\n"
           "if(i%50==10)\n"
             "w.yz*=m(.25*a*d());\n"
           "if(i==20+int(sin(x)*45))\n"
             "{\n"
               "w.xy*=m(.25*a*d()+x);\n"
               "if(t.z>.5)\n"
                 "r.xy*=m(t.x);\n"
             "}\n"
           "if(t.x>.7)\n"
             "r=r/(dot(r,r)-.1+sin(x)*.5+.5)*(1.+sin(x+sin(x)));\n"
         "}\n"
       "else if(D.y<1.)\n"
         "{\n"
           "if(i==20)\n"
             "w.xz*=m(.25*a);\n"
           "if(i%50==50+int(sin(x*.6)*45))\n"
             "w.yz*=m(.25*a*d()),r+=w;\n"
           "if(i==20+int(sin(x*.3+float(f))*25))\n"
             "r+=w*(1.+T),w.xy*=m(.5*a*d());\n"
         "}\n"
       "r=abs(u)>1e-4?\n"
         "pmod(r,3.+u):\n"
         "pmod(r,3.);\n"
       "vec3 g;\n"
       "{\n"
         "vec3 e=r;\n"
         "if(v)\n"
           "{\n"
             "e=sin(e*5.+x);\n"
             "e.xz*=m(x*2.+sin(x*2.));\n"
             "if(y)\n"
               "e=e/(dot(e,e)-.2)+.4,e/=dot(e,e)-.2,e.xz*=m(x);\n"
           "}\n"
         "else\n"
           " e.xz*=m(floor(l(floor(x+50))*4.)/4.*a*2.);\n"
         "e.z+=4.;\n"
         "float F=e.z;\n"
         "if(x<316)\n"
           "e/=e.z*p;\n"
         "e.z=F;\n"
         "e.x/=R.x/R.y;\n"
         "g=e;\n"
         "g.xy+=A()*abs(g.z-C)*.05*b;\n"
       "}\n"
       "vec2 e=g.xy/2.+.5;\n"
       "uvec2 F=uvec2(e.xy*R.xy);\n"
       "uint B=F.x+uint(R.x)*uint(F.y);\n"
       "atomicAdd(z[B],7),atomicAdd(z[B*(1+uint(t.x*6.+x)%2)%uint(R.x*R.y)],uint(111));\n"
     "}\n"
 "}";

#endif // SHADER_INCLUDES_H_
