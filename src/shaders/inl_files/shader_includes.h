// Generated with Shader Minifier 1.4.0 (https://github.com/laurentlb/Shader_Minifier/)
#ifndef SHADER_INCLUDES_H_
# define SHADER_INCLUDES_H_

static const char* music_comp =
 "#version 460 core\n"
 "layout(local_size_x=256,local_size_y=1,local_size_z=1)in;\n"
 "layout(std430,binding=0) buffer A{vec2 f[];};\n"
 "const float s=acos(-1.),v=2.*s;\n"
 "uvec3 t(uvec3 f)\n"
 "{\n"
   "f=f*1664525u+1013904223u;\n"
   "f.x+=f.y*f.z;\n"
   "f.y+=f.z*f.x;\n"
   "f.z+=f.x*f.y;\n"
   "f^=f>>16u;\n"
   "f.x+=f.y*f.z;\n"
   "f.y+=f.z*f.x;\n"
   "f.z+=f.x*f.y;\n"
   "return f;\n"
 "}\n"
 "vec3 p(vec3 f)\n"
 "{\n"
   "uvec3 v=t(floatBitsToUint(f*125.12));\n"
   "return vec3(v)/float(-1u);\n"
 "}\n"
 "vec3 n(vec3 f)\n"
 "{\n"
   "f+=12.124;\n"
   "uvec3 v=floatBitsToUint(f);\n"
   "v=(v>>16u^v.yzx)*1111111111u;\n"
   "v=(v>>16u^v.yzx)*1111111111u;\n"
   "v=(v>>16u^v.yzx)*1111111111u;\n"
   "return vec3(v)/float(-1u);\n"
 "}\n"
 "vec3 d(float f)\n"
 "{\n"
   "return n(vec3(f));\n"
 "}\n"
 "float r(float f)\n"
 "{\n"
   "return 440.*pow(2.,f/12.);\n"
 "}\n"
 "mat2 m(float f)\n"
 "{\n"
   "return mat2(cos(f),-sin(f),sin(f),cos(f));\n"
 "}\n"
 "vec3 d(vec3 f,float v,float u)\n"
 "{\n"
   "vec4 T=vec4(0);\n"
   "for(int i=0;i++<5;)\n"
     "f.yz*=m(4.5),f.xy*=m(1.5),f+=sin(f.zxy),T=(T+vec4(cross(cos(f),sin(f.yzx)),1))/v,f*=u;\n"
   "return T.xyz/T.w;\n"
 "}\n"
 "void main()\n"
 "{\n"
   "uint T=gl_GlobalInvocationID.x;\n"
   "vec2 i=vec2(0);\n"
   "float s=float(T)/44100.,x=float(T%264600)/44100.;\n"
   "if(s>280.)\n"
     "{\n"
       "float f=exp(-mod(s,4.)*10.);\n"
       "i+=f*sin(x*30.*v+sin(x*30.*v*10.)*f*.2)*4.;\n"
     "}\n"
   "float u=1.;\n"
   "if(s>250.)\n"
     "{\n"
       "float f=2.+sin(s)*2e-4;\n"
       "s*=4.;\n"
       "float v=floor(-s/f);\n"
       "s=mod(-s,f)+d(v).x*4.+(s/4.-260.)*.6;\n"
       "u=smoothstep(0.,.04,mod(-s,f))*smoothstep(f,f-.04,mod(-s,f))*4.;\n"
       "x*=.5+d(v).z*.02;\n"
     "}\n"
   "else\n"
     " s=mix(s,0.,pow(clamp((s-230.)*.04,0.,1.),2.));\n"
   "float z=4e2;\n"
   "float[4] c=float[](-12.,1.,3.,10.);\n"
   "z=1e3;\n"
   "\n#if false\n"
   "\n#endif\n"
   "{\n"
     "float[7] R=float[](0.,1.,3.,5.,7.,8.,10.);\n"
     "for(float f=10.;f++<2435.+min(s,0);)\n"
       "{\n"
         "float T=60./140.*4.,y=s;\n"
         "y-=T*floor(d(f).z*4.);\n"
         "y-=T*pow(d(f).y,1.2)*(1.+6.*smoothstep(10.,20.,s));\n"
         "float u=floor(y/(T*4.)),z=smoothstep(0.,4.,u)*.5;\n"
         "y=mod(y,T*4.);\n"
         "z=r(R[int(f+u)%R.length()]-12.+12.*float(d(f+u).y<.4*z)+12.*float(d(f+u).x<.4*z)-12.*float(d(f+u).z<.5*z)-12.*float(d(f*1.5+u).z<.5*z)-12.*float(d(f*1.25+u).z<.2*z));\n"
         "float c=2.+pow(d(f+u).x,2.5)*20.;\n"
         "for(float p=0.;p<c+min(s,0);p++)\n"
           "{\n"
             "float r=1.+smoothstep(0.,4.,u)*2.*exp(-mod(s,1.))*smoothstep(0.,.004,mod(s,1.)),l=pow(d(f+p*1.5+u).x,2.+.5*smoothstep(5e2,2e3,z));\n"
             "z*=1.+floor(l*r);\n"
             "z+=(d(p+f*1.4).x-.5)*20.*smoothstep(0.,30.,s);\n"
             "r=exp(-y*(7.-6.*smoothstep(2e3,8e2,z))*.7)*smoothstep(T*2.,0.,y)*smoothstep(0.,.002,y)*smoothstep(7e3,8e2,z);\n"
             "vec2 R=vec2(sin(v*z*x+sin(d(f*2.4+u).x*15.*x)*4.*smoothstep(10.,20.,s)+sin(v*z*x*2.)*r*r*r*.6*smoothstep(20.,60.,s)))*m(f);\n"
             "i+=r*R/2425./c*30.3*(float(s<60.)+smoothstep(160.,180.,s)*4.);\n"
           "}\n"
       "}\n"
   "}\n"
   "z=4e2;\n"
   "for(float f=0.;++f<z;)\n"
     "{\n"
       "float T=s-pow(smoothstep(0.,1.,p(vec3(f)).x),1.2)*(.2+3.*p(vec3(f)).y);\n"
       "if(f<2.)\n"
         "T=s;\n"
       "float[4] m=float[](c[0],c[1],c[2],c[3]);\n"
       "if(mod(T,8)<1.)\n"
         "for(int f=0;f<4;f++)\n"
           "m[f]+=7;\n"
       "float u=mix(10.,.5+sin(T*.5)*2./T*smoothstep(10.,20.,s),smoothstep(0.,60.,s)),y=floor(T/u),a=mod(T,u);\n"
       "u=m[int(mod(y,4.))]-12.*float(p(vec3(y)).x<.2)+12.*float(p(vec3(y)).z<.2);\n"
       "u=r(u+12.*float(T>60.)-12.-12.);\n"
       "u-=12.*float(p(vec3(y)).x<.2);\n"
       "y=smoothstep(0.,.004,a)*exp(-a*10.);\n"
       "T=(2.+10.*smoothstep(60.,1e2,s))*(y*y*sin(x*u*v));\n"
       "if(f<2.)\n"
         "i+=y*sin(x*u*v+T)*.3;\n"
       "else\n"
         "{\n"
           "float s=a*0.;\n"
           "i+=7.*y*sin(x*u*v+T+d(vec3(vec2(sin(s),cos(s)),f),1.,1.).xy*30.)/z;\n"
         "}\n"
     "}\n"
   "i*=.14;\n"
   "z=44.-10.*smoothstep(30.,50.,s);\n"
   "for(int f=0;f<4;f++)\n"
     "for(float T=0.;++T<z;)\n"
       "{\n"
         "float u=s,x=r(c[f]+12.*float(p(vec3(T)).z<.1)+12.*float(p(vec3(T)*1e2).x<.1)-12.*float(p(vec3(T)).x<.5)-12.);\n"
         "x+=12.*float(p(vec3(T)).z<.1);\n"
         "x-=p(vec3(T)*4.).x*smoothstep(120.,144.,s)*1e2;\n"
         "u=v*x*u+sin(T*4.+float(f)+s*.3)*14.;\n"
         "vec2 y=d(vec3(fract(u/v))*vec3(2,-3,-8),.5,.4).xy*m(T*.2)-d(vec3(vec2(sin(u),cos(u)),T*.1+float(f)),.5,smoothstep(120.,144.,s)*2.).xy*m(-T*.5);\n"
         "i+=y/z*.15*smoothstep(60.,1e2,s);\n"
       "}\n"
   "vec2 y=vec2(0);\n"
   "z=4.;\n"
   "for(float f=0.;++f<z;)\n"
     "{\n"
       "float T=s,u=.5+sin(T*.5)*2./T,i=mod(T,u),p=r(c[0]-12.-12.-12.),m=smoothstep(160.,180.,s);\n"
       "i=smoothstep(0.,.04,i)*exp(-i*(20.-15.*m))*smoothstep(u,0.,i);\n"
       "u=i*i*sin(x*(p*(1.+m*10.*floor(d(floor(T/u)).x*10.)))*v)*(1.-.9*m);\n"
       "i*=smoothstep(1e2,110.,s);\n"
       "if(s>60&&s<70.)\n"
         "i=exp(-s+60.)*4.;\n"
       "if(s>80&&T<1e2)\n"
         "i=exp(-mod(s,4.))*.4;\n"
       "i*=1.+0.*smoothstep(140.,150.,s);\n"
       "y+=i*sin(x*p*v+u)/z*2.;\n"
     "}\n"
   "i=tanh((i+y)*1.2);\n"
   "f[T+3000000]=i*u;\n"
 "}";

static const char* post_frag =
 "#version 460 core\n"
 "layout(location=0) uniform int F;\n"
 "layout(location=1) uniform float T;\n"
 "layout(location=2) uniform vec2 R;\n"
 "layout(std430,binding=0) coherent buffer Aa{uint i[];};\n"
 "out vec4 C;\n"
 "uint u=111425u;\n"
 "uint c(uint f)\n"
 "{\n"
   "f=(f^f>>16)*2146121005u;\n"
   "f=(f^f>>15)*2221713035u;\n"
   "return f^f>>16;\n"
 "}\n"
 "float y(float f)\n"
 "{\n"
   "return float(c(uint(f)))/float(-1u);\n"
 "}\n"
 "float c()\n"
 "{\n"
   "uint f=c(u);\n"
   "u=f;\n"
   "return float(f)/float(-1u);\n"
 "}\n"
 "uint w(ivec2 f)\n"
 "{\n"
   "return(f.x+uint(R.x)*f.y+uint(R.x*R.y))%uint(R.x*R.y);\n"
 "}\n"
 "vec3[4] z=vec3[](vec3(1),vec3(1,0,1),vec3(1,1,.1),vec3(.5,1,1)*1.5);\n"
 "vec3 e(float f)\n"
 "{\n"
   "int T=int(f*float(4));\n"
   "f=smoothstep(0.,1.,fract(f*float(4)));\n"
   "return mix(z[T],z[(T+1)%4],f);\n"
 "}\n"
 "void main()\n"
 "{\n"
   "u=uint(gl_FragCoord.x+gl_FragCoord.y*1111);\n"
   "c();\n"
   "float f=smoothstep(250.,250.1,T),s=smoothstep(280.,280.1,T),v=exp(-mod(T,.5+sin(T*.5)*2./T)*40.);\n"
   "v=.03+.1*smoothstep(90.,190.,T)-f+10.*s*smoothstep(4.,0.,mod(T,4.));\n"
   "float z=smoothstep(0.,50.,T)*pow(y(floor(T)),2)*(1.-f+s);\n"
   "if(T>80&&T<1e2)\n"
     "z=1e2*smoothstep(1.,0.,mod(T,4.));\n"
   "uint m=w(ivec2(gl_FragCoord.xy));\n"
   "vec3 x=vec3(i[m])*1e-4,a=e(mod(x.x*115.,1.));\n"
   "x/=1.+x;\n"
   "x=y(floor(T*.8))<.7?\n"
     "1.-x:\n"
     "pow(abs(pow(step(x,vec3(.5)),vec3(.02))),vec3(.02));\n"
   "if(T>60&&T<65.)\n"
     "x=1.-x;\n"
   "if(abs(x.x-.1)<v)\n"
     "x-=a;\n"
   "C=vec4(pow(abs(x),vec3(4.400000044)),1);\n"
   "if(mod(T,9.-s*5.)<1.)\n"
     "i[m]=0;\n"
   "else if(x.x<z)\n"
     "{\n"
       "ivec2 f=-ivec2(0,4);\n"
       "f*=(int(c()<x.x*1111.)*2-1)*(1+5*int(y(floor(T))));\n"
       "f=f*(int(y(floor(T)*124.)*2.)*2-1)*(1+int(s*smoothstep(3.,0.,mod(T,4.))*20.));\n"
       "if(T>122)\n"
         "f=ivec2(f.y,f.x);\n"
       "if(T>316&&c()>.5)\n"
         "f=ivec2(f.y,f.x)/10;\n"
       "i[m]=i[w(ivec2(gl_FragCoord.xy)+f)];\n"
     "}\n"
   "else\n"
     " i[m]=0;\n"
   "if(f>.1)\n"
     "C=1.-C;\n"
 "}";

static const char* render_comp =
 "#version 460 core\n"
 "layout(local_size_x=256,local_size_y=1,local_size_z=1)in;\n"
 "layout(std430,binding=0) coherent buffer Aaa{uint x[];};\n"
 "layout(location=1) uniform float Tt;\n"
 "layout(location=2) uniform vec2 R;\n"
 "float a;\n"
 "const float A=acos(-1.),l=acos(-1.)*2.;\n"
 "uint g=111425u;\n"
 "uint c(uint f)\n"
 "{\n"
   "f=(f^f>>16)*2146121005u;\n"
   "f=(f^f>>15)*2221713035u;\n"
   "return f^f>>16;\n"
 "}\n"
 "float y(float f)\n"
 "{\n"
   "return float(c(uint(f)))/float(-1u);\n"
 "}\n"
 "float c()\n"
 "{\n"
   "uint f=c(g);\n"
   "g=f;\n"
   "return float(f)/float(-1u);\n"
 "}\n"
 "vec3 b(float f)\n"
 "{\n"
   "return vec3(y(f),y(f),y(f));\n"
 "}\n"
 "vec2 b()\n"
 "{\n"
   "vec2 f=vec2(c(),c());\n"
   "return vec2(sin(f.x*l),cos(f.x*l))*sqrt(f.y);\n"
 "}\n"
 "#define pmod(p,amt)(mod((p+amt*0.5),amt)-amt*0.5)\n"
 "mat2 m(float f)\n"
 "{\n"
   "return mat2(cos(f),-sin(f),sin(f),cos(f));\n"
 "}\n"
 "float d()\n"
 "{\n"
   "return float(c()<.5)*2.-1.;\n"
 "}\n"
 "void main()\n"
 "{\n"
   "uint f=uint(gl_GlobalInvocationID.x);\n"
   "g=f+1111111u;\n"
   "a=Tt;\n"
   "float s=smoothstep(250.,250.1,a);\n"
   "a-=c()*10.*s;\n"
   "float u=exp(-mod(a,.5+sin(a*.5)*2./a)*4.);\n"
   "u=(.4*smoothstep(45.,15.,a)-.4*smoothstep(160.,180.,a)*u+.4*smoothstep(314.,320.,a)*u)*(1.-s);\n"
   "float T=2e2*smoothstep(25.,65.,a);\n"
   "bool v=mod(a,8.)<2.,z=y(floor(a+1555))>.5;\n"
   "float i=1.+.02*smoothstep(90.,150.,a),l=.2+.4*smoothstep(60.,80.,a)-.4*smoothstep(90.,110.,a)-.4*smoothstep(120.,160.,a),e=1.-smoothstep(90.,110.,a)+smoothstep(90.,150.,a);\n"
   "if(a<10.)\n"
     "v=false;\n"
   "int n=30+int(T);\n"
   "T=a;\n"
   "T+=sin(T)*.8;\n"
   "vec3 p=vec3(0);\n"
   "float r=sin(a*9.)*4.*smoothstep(280.,280.1,a);\n"
   "vec2 C=vec2(100,0)*s*(1.-smoothstep(314.,320.,a));\n"
   "vec3 D=vec3(c(),c(),c()),t=b(floor(a)),w=(D.y<.5?\n"
     "vec3(0,-1,0):\n"
     "vec3(1,0,0))*i;\n"
   "t*=e;\n"
   "for(int i=0;i<n;i++)\n"
     "{\n"
       "float s=c();\n"
       "p+=w*(.002*(1.+20.*t.x)+sin(float(f.x))*.01);\n"
       "if(D.y<.5)\n"
         "{\n"
           "if(i%10==0)\n"
             "w+=p;\n"
           "if(i%50==10)\n"
             "w.yz*=m(.25*A*d());\n"
           "if(i==20+int(sin(a)*45))\n"
             "{\n"
               "w.xy*=m(.25*A*d()+a);\n"
               "if(t.z>.5)\n"
                 "p.xy*=m(t.x);\n"
             "}\n"
           "if(t.x>.7)\n"
             "p=p/(dot(p,p)-.1+sin(a)*.5+.5)*(1.+sin(a+sin(a)));\n"
         "}\n"
       "else if(D.y<1.)\n"
         "{\n"
           "if(i==20)\n"
             "w.xz*=m(.25*A);\n"
           "if(i%50==50+int(sin(a*.6)*45))\n"
             "w.yz*=m(.25*A*d()),p+=w;\n"
           "if(i==20+int(sin(a*.3+float(f))*25))\n"
             "p+=w*(1.+T),w.xy*=m(.5*A*d());\n"
         "}\n"
       "p=abs(u)>1e-4?\n"
         "pmod(p,3.+u):\n"
         "pmod(p,3.);\n"
       "vec3 g;\n"
       "{\n"
         "vec3 e=p;\n"
         "if(v)\n"
           "{\n"
             "e=sin(e*5.+a);\n"
             "e.xz*=m(a*2.+sin(a*2.));\n"
             "if(z)\n"
               "e=e/(dot(e,e)-.2)+.4,e/=dot(e,e)-.2,e.xz*=m(a);\n"
           "}\n"
         "else\n"
           " e.xz*=m(floor(y(floor(a+50))*4.)/4.*A*2.);\n"
         "e.z+=4.;\n"
         "float F=e.z;\n"
         "e/=e.z*l;\n"
         "e.z=F;\n"
         "e.x/=R.x/R.y;\n"
         "g=e;\n"
         "g.xy+=b()*abs(g.z-r)*.05*C;\n"
       "}\n"
       "vec2 e=g.xy/2.+.5;\n"
       "uvec2 F=uvec2(e.xy*R.xy);\n"
       "uint B=F.x+uint(R.x)*uint(F.y);\n"
       "atomicAdd(x[B],7),atomicAdd(x[B*(1+uint(t.x*6.+a)%2)%uint(R.x*R.y)],uint(111));\n"
     "}\n"
 "}";

#endif // SHADER_INCLUDES_H_
