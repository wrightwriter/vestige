// Generated with Shader Minifier 1.4.0 (https://github.com/laurentlb/Shader_Minifier/)
#ifndef SHADER_INCLUDES_H_
# define SHADER_INCLUDES_H_

static const char* music_comp =
 "#version 460\n"
 "layout(local_size_x=256)in;"
 "layout(std430,binding=0) buffer Aa{vec2 i[];};"
 "layout(location=0) uniform int offs;"
 "float f=2.*acos(-1.);"
 "uvec3 t(uvec3 f)"
 "{"
   "f=f*1664525u+1013904223u;"
   "f.x+=f.y*f.z;"
   "f.y+=f.z*f.x;"
   "f.z+=f.x*f.y;"
   "f^=f>>16u;"
   "f.x+=f.y*f.z;"
   "f.y+=f.z*f.x;"
   "f.z+=f.x*f.y;"
   "return f;"
 "}"
 "vec3 s(vec3 f)"
 "{"
   "uvec3 T=t(floatBitsToUint(f*125.12));"
   "return vec3(T)/float(-1u);"
 "}"
 "vec3 p(vec3 f)"
 "{"
   "f+=12.124;"
   "uvec3 i=floatBitsToUint(f);"
   "i=(i>>16u^i.yzx)*1111111111u;"
   "i=(i>>16u^i.yzx)*1111111111u;"
   "i=(i>>16u^i.yzx)*1111111111u;"
   "return vec3(i)/float(-1u);"
 "}"
 "vec3 n(float f)"
 "{"
   "return p(vec3(f));"
 "}"
 "float r(float f)"
 "{"
   "return 440.*pow(2.,f/12.);"
 "}"
 "mat2 d(float f)"
 "{"
   "return mat2(cos(f),-sin(f),sin(f),cos(f));"
 "}"
 "vec3 d(vec3 f,float T,float u)"
 "{"
   "vec4 i=vec4(0);"
   "for(int v=0;v++<5;)"
     "f.yz*=d(4.5),f.xy*=d(1.5),f+=sin(f.zxy),i=(i+vec4(cross(cos(f),sin(f.yzx)),1))/T,f*=u;"
   "return i.xyz/i.w;"
 "}"
 "void main()"
 "{"
   "uint T=gl_GlobalInvocationID.x+uint(offs);"
   "vec2 v=vec2(0),x=vec2(0);"
   "float u=float(T)/44100.,m=u,y=float(T%529200)/44100.,z=smoothstep(430.,470.,m),e=1.;"
   "if(u>280.)"
     "{"
       "float i=mod(u,4.),s=exp(-i*10.);"
       "i=30.+pow(z,40.)*1e2;"
       "v+=s*sin(y*i*f+sin(y*i*f*10.)*s*.2)*20.;"
     "}"
   "if(u>250.)"
     "{"
       "float f=2.+sin(u)*2e-4;"
       "u*=4.;"
       "float T=floor(-u/f),v=mod(-u,f);"
       "u=v+n(T).x*4.+(u/4.-260.)*.6;"
       "e=smoothstep(0.,f*.04,v)*smoothstep(f,f*.98,v)*(1.-z);"
       "y*=.25+.25*float(m>260.)+n(T).z*.02;"
     "}"
   "else"
     " u=mix(u,0.,pow(clamp((u-230.)*.04,0.,1.),2.));"
   "float C=1e3;"
   "float[4] t=float[](-12.,1.,3.,10.);"
   "vec2 l=vec2(0);"
   "{"
     "float[7] c=float[](0.,1.,3.,5.,7.,8.,10.);"
     "for(float i=10.;i++<2435.;)"
       "{"
         "float v=60./140.*4.,T=u;"
         "T-=v*floor(n(i).z*4.);"
         "T-=v*pow(n(i).y,1.2)*(1.+6.*smoothstep(10.,20.,u));"
         "float s=floor(T/(v*4.)),x=smoothstep(0.,4.,s)*.5;"
         "T=mod(T,v*4.);"
         "x=r(c[int(i+s)%7]-12.+12.*float(n(i+s).y<.4*x)+12.*float(n(i+s).x<.4*x)-12.*float(n(i+s).z<.5*x)-12.*float(n(i*1.5+s).z<.5*x)-12.*float(n(i*1.25+s).z<.2*x));"
         "float C=2.+pow(n(i+s).x,2.5)*20.;"
         "for(float r=0.;r<C;r++)"
           "{"
             "float e=x,a=1.+smoothstep(0.,4.,s)*2*exp(-mod(u,1.)),c=pow(n(i+r*1.5+s).x,2.+.5*smoothstep(5e2,2e3,e));"
             "e*=1.+floor(c*a);"
             "e+=(n(r+i*1.4).x-.5)*20.*smoothstep(0.,30.,u);"
             "a=exp(-T*(7.-6.*smoothstep(2e3,8e2,e))*.7)*smoothstep(v*2.,0.,T)*smoothstep(0.,.002,T)*smoothstep(7e3,8e2,e);"
             "vec2 p=vec2(sin(f*e*y+sin(n(i*2.4+s).x*15*y)*4.*smoothstep(10,20,u)+sin(f*e*y*2)*a*a*a*.6*smoothstep(20,60,u)))*d(i);"
             "p=m<260?"
               "mix(p,tanh(p),0.):"
               "p*2.;"
             "l+=a*p/2425./C*2e2*(float(u<60.)+z*4.);"
           "}"
       "}"
   "}"
   "v+=l;"
   "C=4e2;"
   "for(float T=0.;++T<C;)"
     "{"
       "float i=u-pow(smoothstep(0.,1.,s(vec3(T)).x),1.2)*(.2+3.*s(vec3(T)).y);"
       "if(T<2.)"
         "i=u;"
       "float[4] m=float[](t[0],t[1],t[2],t[3]);"
       "if(mod(i,8)<1.)"
         "for(int i=0;i<4;i++)"
           "m[i]+=7;"
       "float x=mix(10.,.5+sin(i*.5)*2./i*smoothstep(10.,20.,u),smoothstep(0.,60.,u));"
       "int n=int(i/x);"
       "x=mod(i,x);"
       "float e=m[n%4]-12*float(s(vec3(n)).x<.2)+12*float(s(vec3(n)).z<.2);"
       "e=r(e+12.*float(i>60.)-24.);"
       "e-=12.*float(s(vec3(n)).x<.2);"
       "x=smoothstep(0.,.004,x)*exp(-x*10.);"
       "i=(2.+10.*smoothstep(60.,1e2,u))*(x*x*sin(y*e*f));"
       "if(T<2.)"
         "v+=x*sin(y*e*f+i*smoothstep(1400.,5e2,e))*.3*6.;"
       "else"
         "{"
           "vec2 m=vec2(7.*x*sin(y*e*f+i*(1.-float(u>260.)*.4)+d(vec3(1,.5,T),1.,1.).xy*30.))/C*6.;"
           "v+=m;"
         "}"
     "}"
   "v*=.14;"
   "C=44.-10.*smoothstep(30.,50.,u);"
   "for(int i=0;i<4;i++)"
     "for(float T=0.;++T<C;)"
       "{"
         "float x=u,e=r(t[i]+12.*float(s(vec3(T)).z<.1)+12.*float(s(vec3(T)*1e2).x<.1)-12.*float(s(vec3(T)).x<.5)-12.);"
         "e+=12.*float(s(vec3(T)).z<.1);"
         "e-=s(vec3(T)*4.).x*smoothstep(120.,144.,u)*1e2;"
         "if(m>340)"
           "x=y*2.;"
         "x*=f*e;"
         "vec2 p=d(vec3(fract(x/f))*vec3(2,-3,-8),.5,.4).xy*d(T*.2)-d(vec3(vec2(sin(x),cos(x)),T*.1+float(i)),.5,smoothstep(120.,144.,u)*2.).xy*d(-T*.5);"
         "v+=p/C*.15*smoothstep(60.,1e2,u)*5.*smoothstep(250.,230.,m);"
       "}"
   "C=4.;"
   "for(float i=0.;++i<C;)"
     "{"
       "float T=u,s=.5+sin(T*.5)*2./T,v=mod(T,s),e=r(t[0]-12.-12.-12.),z=smoothstep(160.,180.,u);"
       "v=smoothstep(0.,.04,v)*exp(-v*(20.-15.*z))*smoothstep(s,0.,v);"
       "s=v*v*sin(y*(e*(1.+z*10.*floor(n(floor(T/s)).x*10.)))*f)*(1.-.9*z);"
       "v*=smoothstep(1e2,110.,u);"
       "if(u>60&&u<70.)"
         "v=exp(-u+60.)*4.;"
       "if(u>80&&T<1e2)"
         "v=exp(-mod(u,4.))*.4;"
       "v*=1.;"
       "x+=v*sin(y*e*f+s)/C*6.;"
     "}"
   "v=clamp(tanh((v*2.+x)*1.2*smoothstep(0.,5.,m))*.7,-1.,1.);"
   "i[T+3000000]=v*e+tanh(l*z*.2+sin(f*30.*m)*10.*pow(z,30.));"
 "}";

static const char* post_frag =
 "#version 460\n"
 "layout(location=1) uniform float T;"
 "layout(std430,binding=0) coherent buffer Aa{uint v[];};"
 "out vec4 C;"
 "uint u;"
 "uint m(uint f)"
 "{"
   "f=(f^f>>16)*2146121005u;"
   "f=(f^f>>15)*2221713035u;"
   "return f^f>>16;"
 "}"
 "float x(float f)"
 "{"
   "return float(m(uint(f)))/float(-1u);"
 "}"
 "float d()"
 "{"
   "uint f=m(u);"
   "u=f;"
   "return float(f)/float(-1u);"
 "}"
 "uint w(ivec2 f)"
 "{"
   "f+=10;"
   "return(f.x+1300*f.y+uint(962000))%uint(962000);"
 "}"
 "float d(inout vec2 f,inout float i,int s,int x)"
 "{"
   "int[148] T=int[](-1,-1,-1,1,-1,1,1,1,-1,1,-1,-1,-1,-1,1,-1,-1,-1,-1,1,-1,1,1,1,-1,0,1,0,-1,1,-1,-1,1,1,1,-1,-1,-1,-1,1,-1,1,1,1,-1,1,-1,-1,1,1,1,-1,-1,-1,-1,1,-1,1,1,1,0,1,0,-1,-1,-1,-1,1,-1,1,1,1,-1,-1,1,-1,-1,1,-1,-1,1,0,1,-1,1,0,0,0,-1,-1,-1,1,-1,1,1,1,-1,-1,1,-1,-1,1,-1,-1,1,1,1,-1,-1,-1,-1,1,-1,1,1,1,-1,-1,1,-1,-1,0,1,0,-1,1,-1,-1,1,1,1,-1,-1,-1,-1,1,-1,0,1,-1,-1,0,1,1,-1,1,-1,-1);"
   "for(int v=s;++v<x+s;)"
     "{"
       "vec2 u=vec2(T[v*4],T[v*4+1]),e=vec2(T[v*4+2],T[v*4+3]);"
       "float C=length(e-u);"
       "vec2 m=(e-u)/C;"
       "u=abs(mat2(m.x,-m.y,m.y,m.x)*(f-(u+e)/2))-vec2(C,.2)/2;"
       "i=min(i,length(max(u,0.))+min(max(u.x-.2,u.y),0.));"
     "}"
   "f.x-=2.5;"
   "return i;"
 "}"
 "void main()"
 "{"
   "float f=float(T>250),s=float(T>280),i=exp(-mod(T,.5+sin(T/2)*2/T)*40.),e=.03+.05*smoothstep(90.,190.,T)-f+4.*s*smoothstep(4.,0.,mod(T,4.));"
   "i=(smoothstep(0,50,T)*pow(x(floor(T)),2)+.9*smoothstep(160,190,T)*i)*(1-f+s);"
   "u=uint(gl_FragCoord.x+gl_FragCoord.y*1111);"
   "d();"
   "if(T>80&&T<100)"
     "i=100*smoothstep(1,0,mod(T,4.));"
   "uint m=w(ivec2(gl_FragCoord.xy));"
   "vec3 n=vec3(v[m])*1e-4;"
   "float y=n.x*460;"
   "vec3[4] t=vec3[](vec3(1),vec3(1,0,1),vec3(1,1,.1),vec3(.75,1.5,1.5));"
   "vec3 p=mix(t[int(y)%4],t[int(y+1)%4],smoothstep(0.,1.,fract(y)));"
   "n/=1.+n;"
   "n=x(floor(T*.8))<.7?"
     "1.-n:"
     "pow(abs(pow(step(n,vec3(.5)),vec3(.02))),vec3(.02));"
   "if(T>60&&T<65)"
     "n=1-n;"
   "if(abs(n.x-.1)<e)"
     "n-=p;"
   "C=pow(abs(n.xyzz),vec4(4.4));"
   "if(T>460)"
     "v[m]=v[m]*400%10000000;"
   "else if(mod(T,9.-s*5.)<1.-float(T>460.))"
     "v[m]=0;"
   "else if(n.x<i)"
     "{"
       "ivec2 f=-ivec2(0,4);"
       "f*=(int(d()<n.x*1111.)*2-1)*(1+5*int(x(floor(T))));"
       "f=f*(int(x(floor(T)*124.)*2.)*2-1)*(1+int(s*smoothstep(3.,0.,mod(T,4.))*20.));"
       "if(T>122&&T<250.)"
         "f=ivec2(f.y,f.x);"
       "if(T>316&&d()>.5)"
         "f-=f;"
       "v[m]=v[w(ivec2(gl_FragCoord.xy)+f)];"
     "}"
   "else"
     " v[m]=0;"
   "if(f>.1)"
     "C=1.-C;"
   "if(T>350.)"
     "C=vec4(dot(C,C)<.5);"
   "vec2 c=(gl_FragCoord.xy-vec2(1280,720)/2)/720*20;"
   "y=10.;"
   "if(int(T)%3==0)"
     "c.x+=3.75,d(c,y,0,4),d(c,y,4,5),d(c,y,9,4),d(c,y,13,3);"
   "else if(int(T)%3==1)"
     "c.x+=1.23,d(c,y,16,6),d(c,y,22,5);"
   "else"
     " c.x+=3.75,d(c,y,27,6),d(c,y,4,5),d(c,y,0,4),d(c,y,33,4);"
   "if(y<0.&&(T>420&&T<450))"
     "v[m]+=100000;"
 "}";

static const char* render_comp =
 "#version 460\n"
 "layout(local_size_x=256)in;"
 "layout(std430,binding=0) coherent buffer Aa{uint c[];};"
 "layout(location=1) uniform float Tt;"
 "vec2 e=vec2(1300,740);"
 "float y=acos(-1.);"
 "uint l;"
 "uint m(uint f)"
 "{"
   "f=(f^f>>16)*2146121005u;"
   "f=(f^f>>15)*2221713035u;"
   "return f^f>>16;"
 "}"
 "float x(float f)"
 "{"
   "return float(m(uint(f)))/float(-1u);"
 "}"
 "float d()"
 "{"
   "uint f=m(l);"
   "l=f;"
   "return float(f)/float(-1u);"
 "}"
 "vec3 h(float f)"
 "{"
   "return vec3(x(f),x(f),x(f));"
 "}\n"
 "#define pmod(p,amt)(mod((p+amt/2),amt)-amt/2)\n"
 "mat2 d(float f)"
 "{"
   "return mat2(cos(f),-sin(f),sin(f),cos(f));"
 "}"
 "float h()"
 "{"
   "return float(d()<.5)*2.-1.;"
 "}"
 "void main()"
 "{"
   "uint f=gl_GlobalInvocationID.x;"
   "l=f+1111111u;"
   "float T=mod(Tt,360),i=float(T>250),s=.5+sin(T/2)*2/T;"
   "s=exp(-mod(T,s)*4);"
   "float v=smoothstep(155,180,T)*smoothstep(250,249,T);"
   "s=(.4*smoothstep(45,15,T)-.1*v*s*(x(T)-.5)+.4*smoothstep(314,320,T)*s)*(1.-i);"
   "bool u=mod(T,8)<2,m=x(floor(T+1555))>.5;"
   "float C=.2+.4*smoothstep(60,80,T)-.4*smoothstep(90,110,T)-.4*smoothstep(120,160,T)-.2*v;"
   "if(T<10)"
     "u=false;"
   "int n=30+int(200*smoothstep(25,65,T));"
   "float p=T,t=p+sin(p)*.8;"
   "p=sin(T*9)*4*float(T>280);"
   "vec3 r=vec3(0),a=vec3(d(),d(),d()),z=h(floor(T)),g=vec3(1,0,0);"
   "if(a.y<.5)"
     "g=vec3(0,-1,0);"
   "g*=1+.02*smoothstep(90,150,T)-v*.8;"
   "z*=1-smoothstep(90,110,T)+smoothstep(90,150,T);"
   "for(int v=0;v<n;v++)"
     "{"
       "float l=d();"
       "r+=g*(.002*(1+20*z.x)+sin(float(f.x))*.01);"
       "if(a.y<.5)"
         "{"
           "if(v%10==0)"
             "g+=r;"
           "if(v%50==10)"
             "g.yz*=d(y*h()/4);"
           "if(v==20+int(sin(T)*45))"
             "{"
               "g.xy*=d(y*h()/4+T);"
               "if(z.z>.5)"
                 "r.xy*=d(z.x);"
             "}"
           "if(z.x>.7)"
             "r=r/(dot(r,r)-.1+sin(T)*.5+.5)*(1.+sin(T+sin(T)));"
         "}"
       "else if(a.y<1.)"
         "{"
           "if(v==20)"
             "g.xz*=d(.25*y);"
           "if(v%50==50+int(sin(T*.6)*45))"
             "g.yz*=d(y*h()/4),r+=g;"
           "if(v==20+int(sin(T*.3+float(f))*25))"
             "r+=g*(1.+t),g.xy*=d(.5*y*h());"
         "}"
       "r=abs(s)>1e-4?"
         "pmod(r,3+s):"
         "pmod(r,3);"
       "vec3 b=r;"
       "if(u)"
         "{"
           "b=sin(b*5+T);"
           "b.xz*=d(T*2+sin(T*2));"
           "if(m)"
             "b=b/(dot(b,b)-.2)+.4,b/=dot(b,b)-.2,b.xz*=d(T);"
         "}"
       "else"
         " b.xz*=d(floor(x(floor(T+50))*4)/4*y*2);"
       "b.z+=4;"
       "if(T<316)"
         "b.xy/=b.z*C;"
       "b.x=b.x*e.y/e.x+10*(d()-.5)*abs(b.z-p)*(i*(1-smoothstep(314,320,T)));"
       "uvec2 A=uvec2((b.xy/2.+.5)*e);"
       "uint w=A.x+uint(e.x)*A.y;"
       "atomicAdd(c[w],7);"
       "atomicAdd(c[w*(1+uint(z.x*6+T)%2)%uint(e.x*e.y)],uint(111));"
     "}"
 "}";

#endif // SHADER_INCLUDES_H_
