// Generated with Shader Minifier 1.4.0 (https://github.com/laurentlb/Shader_Minifier/)
#ifndef SHADER_INCLUDES_H_
# define SHADER_INCLUDES_H_

static const char* music_comp =
 "#version 460 core\n"
 "layout(local_size_x=256,local_size_y=1,local_size_z=1)in;"
 "layout(std430,binding=0) buffer A{vec2 hist[];};"
 "const float pi=acos(-1.),tau=2.*pi;"
 "vec3 hash3fb(vec3 s)"
 "{"
   "s+=12.124;"
   "uvec3 r=floatBitsToUint(s);"
   "r=(r>>16u^r.yzx)*1111111111u;"
   "r=(r>>16u^r.yzx)*1111111111u;"
   "r=(r>>16u^r.yzx)*1111111111u;"
   "return vec3(r)/float(-1u);"
 "}"
 "vec3 h(float v)"
 "{"
   "return hash3fb(vec3(v));"
 "}"
 "float ntf(float n)"
 "{"
   "return 440.*pow(2.,n/12.);"
 "}"
 "mat2 rot(float t)"
 "{"
   "return mat2(cos(t),-sin(t),sin(t),cos(t));"
 "}"
 "void main()"
 "{"
   "uint samp=gl_GlobalInvocationID.x;"
   "vec2 s=vec2(0);"
   "float T=float(samp)/44100.,Tt=T;"
   "uint repd=264600;"
   "float TT=float(samp%repd)/44100.,genv=1.;"
   "Tt=smoothstep(430.,470.,Tt);"
   "float its=4e2;"
   "float[4] notes=float[](-12.,1.,3.,10.);"
   "its=1e3;"
   "vec2 chord=vec2(0);"
   "{"
     "float its=2425.;"
     "float[7] scale=float[](0.,1.,3.,5.,7.,8.,10.);"
     "for(float i=10.;i++<its+10.+min(T,0);)"
       "{"
         "float replen=60./140.*4.,t=T;"
         "t-=replen*floor(h(i).z*4.);"
         "float tid=floor(t/(replen*4.)),offsc=smoothstep(0.,4.,tid)*.5;"
         "t=mod(t,replen*4.);"
         "offsc=ntf(scale[int(i+tid)%scale.length()]-12.+12.*float(h(i+tid).y<.4*offsc)+12.*float(h(i+tid).x<.4*offsc)-12.*float(h(i+tid).z<.5*offsc)-12.*float(h(i*1.5+tid).z<.5*offsc)-12.*float(h(i*1.25+tid).z<.2*offsc));"
         "float kits=2.+pow(h(i+tid).x,2.5)*20.;"
         "for(float k=0.;k<kits+min(T,0);k++)"
           "{"
             "float f=offsc,ots=1.+smoothstep(0.,4.,tid)*2.*exp(-mod(T,1.))*smoothstep(0.,.004,mod(t,1.));"
             "f=pow(h(i+k*1.5+tid).x,2.+.5*smoothstep(5e2,2e3,offsc));"
             "offsc*=1.+floor(f*ots);"
             "ots=exp(-t*(7.-6.*smoothstep(2e3,8e2,offsc))*.7)*smoothstep(replen*2.,0.,t)*smoothstep(0.,.002,t)*smoothstep(7e3,8e2,offsc);"
             "vec2 wave=vec2(sin(tau*offsc*TT))*rot(i);"
             "chord+=ots*wave/its/kits*200.3*(float(T<60.)+Tt);"
           "}"
       "}"
   "}"
   "s=clamp(tanh((s+chord*.05)*1.2)*2.,-1.,1.);"
   "hist[samp+3000000]=s*genv+chord*Tt;"
 "}";

static const char* post_frag =
 "#version 460 core\n"
 "layout(location=0) uniform int F;"
 "layout(location=1) uniform float T;"
 "layout(location=2) uniform vec2 R;"
 "layout(std430,binding=0) coherent buffer Aa{uint hist[];};"
 "out vec4 C;"
 "uint seed=111425u;"
 "uint hash_u(uint _a)"
 "{"
   "_a=(_a^_a>>16)*2146121005u;"
   "_a=(_a^_a>>15)*2221713035u;"
   "return _a^_a>>16;"
 "}"
 "float hash_f_s(float s)"
 "{"
   "return float(hash_u(uint(s)))/float(-1u);"
 "}"
 "float hash_f()"
 "{"
   "uint s=hash_u(seed);"
   "seed=s;"
   "return float(s)/float(-1u);"
 "}"
 "uint get_hist_id(ivec2 c)"
 "{"
   "return(c.x+uint(R.x)*c.y+uint(R.x*R.y))%uint(R.x*R.y);"
 "}"
 "const int COL_CNT=4;"
 "vec3[4] kCols=vec3[](vec3(1),vec3(1,0,1),vec3(1,1,.1),vec3(.5,1,1)*1.5);"
 "vec3 mix_cols(float idx)"
 "{"
   "int cols_idx=int(idx*float(COL_CNT));"
   "idx=smoothstep(0.,1.,fract(idx*float(COL_CNT)));"
   "return mix(kCols[cols_idx],kCols[(cols_idx+1)%COL_CNT],idx);"
 "}"
 "void main()"
 "{"
   "vec2 uv=gl_FragCoord.xy/R.xy;"
   "seed=uint(gl_FragCoord.x+gl_FragCoord.y*1111);"
   "hash_f();"
   "float end=smoothstep(250.,250.1,T),endb=smoothstep(280.,280.1,T),repd=.5+sin(T*.5)*2./T;"
   "repd=.03+.1*smoothstep(90.,190.,T)-end+4.*endb*smoothstep(4.,0.,mod(T,4.));"
   "float K_GLITCH=smoothstep(0.,50.,T)*pow(hash_f_s(floor(T)),2)*(1.-end+endb);"
   "if(T>80&&T<1e2)"
     "{"
       "float env=smoothstep(1.,0.,mod(T,4.));"
       "K_GLITCH=1e2*env;"
     "}"
   "uint hist_id=get_hist_id(ivec2(gl_FragCoord.xy));"
   "vec3 col=vec3(hist[hist_id])*1e-4,pal=mix_cols(mod(col.x*115.,1.));"
   "col/=1.+col;"
   "col=hash_f_s(floor(T*.8))<.7?"
     "1.-col:"
     "pow(abs(pow(step(col,vec3(.5)),vec3(.02))),vec3(.02));"
   "if(T>60&&T<65.)"
     "col=1.-col;"
   "if(abs(col.x-.1)<repd)"
     "col-=pal;"
   "C=vec4(pow(abs(col),vec3(4.400000044)),1);"
   "if(mod(T,9.-endb*5.)<1.)"
     "hist[hist_id]=0;"
   "else if(col.x<K_GLITCH)"
     "{"
       "ivec2 offs=-ivec2(0,4);"
       "offs*=(int(hash_f()<col.x*1111.)*2-1)*(1+5*int(hash_f_s(floor(T))));"
       "offs=offs*(int(hash_f_s(floor(T)*124.)*2.)*2-1)*(1+int(endb*smoothstep(3.,0.,mod(T,4.))*20.));"
       "if(T>122)"
         "offs=ivec2(offs.y,offs.x);"
       "if(T>316&&hash_f()>.5)"
         "offs-=offs;"
       "hist[hist_id]=hist[get_hist_id(ivec2(gl_FragCoord.xy)+offs)];"
     "}"
   "else"
     " hist[hist_id]=0;"
   "if(end>.1)"
     "C=1.-C;"
   "if(T>350.)"
     "C=vec4(dot(C,C)<.5);"
 "}";

static const char* render_comp =
 "#version 460 core\n"
 "layout(local_size_x=256,local_size_y=1,local_size_z=1)in;"
 "layout(std430,binding=0) coherent buffer Aaa{uint hist[];};"
 "layout(location=1) uniform float Tt;"
 "layout(location=2) uniform vec2 R;"
 "float T;"
 "const float pi=acos(-1.),tau=acos(-1.)*2.;"
 "uint seed=111425u;"
 "uint hash_u(uint _a)"
 "{"
   "_a=(_a^_a>>16)*2146121005u;"
   "_a=(_a^_a>>15)*2221713035u;"
   "return _a^_a>>16;"
 "}"
 "float hash_f_s(float s)"
 "{"
   "return float(hash_u(uint(s)))/float(-1u);"
 "}"
 "float hash_f()"
 "{"
   "uint s=hash_u(seed);"
   "seed=s;"
   "return float(s)/float(-1u);"
 "}"
 "vec2 hash_v2()"
 "{"
   "return vec2(hash_f(),hash_f());"
 "}"
 "vec3 hash_v3_s(float s)"
 "{"
   "return vec3(hash_f_s(s),hash_f_s(s),hash_f_s(s));"
 "}"
 "vec3 hash_v3()"
 "{"
   "return vec3(hash_f(),hash_f(),hash_f());"
 "}"
 "vec2 sample_disk()"
 "{"
   "vec2 X=hash_v2();"
   "return vec2(sin(X.x*tau),cos(X.x*tau))*sqrt(X.y);"
 "}\n"
 "#define pmod(p,amt)(mod((p+amt*0.5),amt)-amt*0.5)\n"
 "mat2 rot(float a)"
 "{"
   "return mat2(cos(a),-sin(a),sin(a),cos(a));"
 "}"
 "float quant(float a,float b)"
 "{"
   "return floor(a*b)/b;"
 "}"
 "float hash_f_p_neg(float prob)"
 "{"
   "return float(hash_f()<prob)*2.-1.;"
 "}"
 "void main()"
 "{"
   "uint id=uint(gl_GlobalInvocationID.x);"
   "seed=id+1111111u;"
   "T=Tt;"
   "T=mod(T,360.);"
   "float end=smoothstep(250.,250.1,T),repd=.5+sin(T*.5)*2./T;"
   "repd=exp(-mod(T,repd)*4.);"
   "repd=(.4*smoothstep(45.,15.,T)-.4*smoothstep(160.,180.,T)*repd+.4*smoothstep(314.,320.,T)*repd)*(1.-end);"
   "float K_ITERS=2e2*smoothstep(25.,65.,T);"
   "bool K_CUBE=mod(T,8.)<2.,K_SPHINV=hash_f_s(floor(T+1555))>.5;"
   "float K_DIR_SC=1.+.02*smoothstep(90.,150.,T),K_PERSP=.2+.4*smoothstep(60.,80.,T)-.4*smoothstep(90.,110.,T)-.4*smoothstep(120.,160.,T),K_RB_SC=1.-smoothstep(90.,110.,T)+smoothstep(90.,150.,T);"
   "if(T<10.)"
     "K_CUBE=false;"
   "bool dbg=true;"
   "int iters=30+int(K_ITERS);"
   "K_ITERS=T;"
   "K_ITERS+=sin(K_ITERS)*.8;"
   "vec3 p=vec3(0);"
   "float focusDist=sin(T*9.)*4.*smoothstep(280.,280.1,T);"
   "vec2 dofFac=vec2(100,0)*end*(1.-smoothstep(314.,320.,T));"
   "vec3 tr=hash_v3(),rb=hash_v3_s(floor(T)),dir=(tr.y<.5?"
     "vec3(0,-1,0):"
     "vec3(1,0,0))*K_DIR_SC;"
   "rb*=K_RB_SC;"
   "for(int i=0;i<iters;i++)"
     "{"
       "float r=hash_f();"
       "p+=dir*(.002*(1.+20.*rb.x)+sin(float(id.x))*.01);"
       "if(tr.y<.5)"
         "{"
           "if(i%10==0)"
             "dir+=p;"
           "if(i%50==10)"
             "dir.yz*=rot(.25*pi*hash_f_p_neg(.5));"
           "if(i==20+int(sin(T)*45))"
             "{"
               "dir.xy*=rot(.25*pi*hash_f_p_neg(.5)+T);"
               "if(rb.z>.5)"
                 "p.xy*=rot(rb.x);"
             "}"
           "if(rb.x>.7)"
             "p=p/(dot(p,p)-.1+sin(T)*.5+.5)*(1.+sin(T+sin(T)));"
         "}"
       "else if(tr.y<1.)"
         "{"
           "if(i==20)"
             "dir.xz*=rot(.25*pi);"
           "if(i%50==50+int(sin(T*.6)*45))"
             "dir.yz*=rot(.25*pi*hash_f_p_neg(.5)),p+=dir;"
           "if(i==20+int(sin(T*.3+float(id))*25))"
             "p+=dir*(1.+K_ITERS),dir.xy*=rot(.5*pi*hash_f_p_neg(.5));"
         "}"
       "p=abs(repd)>1e-4?"
         "pmod(p,3.+repd):"
         "pmod(p,3.);"
       "vec3 q;"
       "{"
         "vec3 p=p;"
         "if(K_CUBE)"
           "{"
             "p=sin(p*5.+T);"
             "p.xz*=rot(T*2.+sin(T*2.));"
             "if(K_SPHINV)"
               "p=p/(dot(p,p)-.2)+.4,p/=dot(p,p)-.2,p.xz*=rot(T);"
           "}"
         "else"
           " p.xz*=rot(quant(hash_f_s(floor(T+50)),4.)*pi*2.);"
         "p.z+=4.;"
         "float z=p.z;"
         "if(T<316)"
           "p/=p.z*K_PERSP;"
         "p.z=z;"
         "p.x/=R.x/R.y;"
         "q=p;"
         "q.xy+=sample_disk()*abs(q.z-focusDist)*.05*dofFac;"
       "}"
       "vec2 uv=q.xy/2.+.5;"
       "uvec2 cc=uvec2(uv.xy*R.xy);"
       "uint idx=cc.x+uint(R.x)*uint(cc.y);"
       "atomicAdd(hist[idx],7),atomicAdd(hist[idx*(1+uint(rb.x*6.+T)%2)%uint(R.x*R.y)],uint(111));"
     "}"
 "}";

#endif // SHADER_INCLUDES_H_
