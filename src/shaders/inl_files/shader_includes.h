// Generated with Shader Minifier 1.4.0 (https://github.com/laurentlb/Shader_Minifier/)
#ifndef SHADER_INCLUDES_H_
# define SHADER_INCLUDES_H_

static const char* music_comp =
 "#version 460 core\n"
 "layout(local_size_x=256,local_size_y=1,local_size_z=1)in;"
 "layout(std430,binding=0) buffer A{vec2 i[];};"
 "layout(location=0) uniform int offs;"
 "const float s=acos(-1.),f=2.*s;"
 "uvec3 t(uvec3 f)"
 "{"
   "f=f*1664525u+1013904223u;"
   "f.x+=f.y*f.z;"
   "f.y+=f.z*f.x;"
   "f.z+=f.x*f.y;"
   "f^=f>>16u;"
   "f.x+=f.y*f.z;"
   "f.y+=f.z*f.x;"
   "f.z+=f.x*f.y;"
   "return f;"
 "}"
 "vec3 p(vec3 f)"
 "{"
   "uvec3 v=t(floatBitsToUint(f*125.12));"
   "return vec3(v)/float(-1u);"
 "}"
 "vec3 n(vec3 f)"
 "{"
   "f+=12.124;"
   "uvec3 v=floatBitsToUint(f);"
   "v=(v>>16u^v.yzx)*1111111111u;"
   "v=(v>>16u^v.yzx)*1111111111u;"
   "v=(v>>16u^v.yzx)*1111111111u;"
   "return vec3(v)/float(-1u);"
 "}"
 "vec3 v(float f)"
 "{"
   "return n(vec3(f));"
 "}"
 "float d(float f)"
 "{"
   "return 440.*pow(2.,f/12.);"
 "}"
 "mat2 r(float f)"
 "{"
   "return mat2(cos(f),-sin(f),sin(f),cos(f));"
 "}"
 "vec3 d(vec3 f,float v,float u)"
 "{"
   "vec4 T=vec4(0);"
   "for(int i=0;i++<5;)"
     "f.yz*=r(4.5),f.xy*=r(1.5),f+=sin(f.zxy),T=(T+vec4(cross(cos(f),sin(f.yzx)),1))/v,f*=u;"
   "return T.xyz/T.w;"
 "}"
 "void main()"
 "{"
   "uint T=gl_GlobalInvocationID.x+uint(offs);"
   "vec2 s=vec2(0);"
   "float x=float(T)/44100.,u=x,y=float(T%529200)/44100.,m=smoothstep(430.,470.,u);"
   "if(x>280.)"
     "{"
       "float i=mod(x,4.),v=exp(-i*10.);"
       "i=30.+pow(m,40.)*1e2;"
       "s+=(v+pow(m,40.)*0.)*sin(y*i*f+sin(y*i*f*10.)*v*.2)*20.;"
     "}"
   "float e=1.;"
   "if(x>250.)"
     "{"
       "float f=2.+sin(x)*2e-4;"
       "x*=4.;"
       "float T=floor(-x/f),s=mod(-x,f);"
       "x=s+v(T).x*4.+(x/4.-260.)*.6;"
       "e=smoothstep(0.,f*.04,s)*smoothstep(f,f*.98,s)*4.*(1.-m);"
       "y*=.25+.25*float(u>260.)+v(T).z*.02;"
     "}"
   "else"
     " x=mix(x,0.,pow(clamp((x-230.)*.04,0.,1.),2.));"
   "float z=4e2;"
   "float[4] c=float[](-12.,1.,3.,10.);"
   "z=1e3;"
   "vec2 n=-pow(m,35.)*(d(.2*vec3(vec2(sin(x),cos(x)),10.*x),.2,.3).xy*30.*40.);"
   "n-=n;"
   "vec2 l=vec2(0);"
   "{"
     "float[7] R=float[](0.,1.,3.,5.,7.,8.,10.);"
     "for(float i=10.;i++<2435.;)"
       "{"
         "float s=60./140.*4.,T=x;"
         "T-=s*floor(v(i).z*4.);"
         "T-=s*pow(v(i).y,1.2)*(1.+6.*smoothstep(10.,20.,x));"
         "float u=floor(T/(s*4.)),e=smoothstep(0.,4.,u)*.5;"
         "T=mod(T,s*4.);"
         "e=d(R[int(i+u)%R.length()]-12.+12.*float(v(i+u).y<.4*e)+12.*float(v(i+u).x<.4*e)-12.*float(v(i+u).z<.5*e)-12.*float(v(i*1.5+u).z<.5*e)-12.*float(v(i*1.25+u).z<.2*e));"
         "float z=2.+pow(v(i+u).x,2.5)*20.;"
         "for(float c=0.;c<z;c++)"
           "{"
             "float p=e,a=1.+smoothstep(0.,4.,u)*2.*exp(-mod(x,1.))*smoothstep(0.,.004,mod(T,1.)),g=pow(v(i+c*1.5+u).x,2.+.5*smoothstep(5e2,2e3,p));"
             "p*=1.+floor(g*a);"
             "p+=(v(c+i*1.4).x-.5)*20.*smoothstep(0.,30.,x);"
             "a=exp(-T*(7.-6.*smoothstep(2e3,8e2,p))*.7)*smoothstep(s*2.,0.,T)*smoothstep(0.,.002,T)*smoothstep(7e3,8e2,p);"
             "vec2 R=vec2(sin(f*p*y+sin(v(i*2.4+u).x*15.*y)*4.*smoothstep(10.,20.,x)+sin(f*p*y*2.)*a*a*a*.6*smoothstep(20.,60.,x)-n))*r(i);"
             "l+=a*R/2425./z*200.3*(float(x<60.)+m*4.);"
           "}"
       "}"
   "}"
   "s+=l;"
   "z=4e2;"
   "for(float v=0.;++v<z;)"
     "{"
       "float i=x-pow(smoothstep(0.,1.,p(vec3(v)).x),1.2)*(.2+3.*p(vec3(v)).y);"
       "if(v<2.)"
         "i=x;"
       "float[4] m=float[](c[0],c[1],c[2],c[3]);"
       "if(mod(i,8)<1.)"
         "for(int i=0;i<4;i++)"
           "m[i]+=7;"
       "float T=mix(10.,.5+sin(i*.5)*2./i*smoothstep(10.,20.,x),smoothstep(0.,60.,x)),u=floor(i/T),a=mod(i,T);"
       "T=m[int(mod(u,4.))]-12.*float(p(vec3(u)).x<.2)+12.*float(p(vec3(u)).z<.2);"
       "T=d(T+12.*float(i>60.)-12.-12.);"
       "T-=12.*float(p(vec3(u)).x<.2);"
       "u=smoothstep(0.,.004,a)*exp(-a*10.);"
       "i=(2.+10.*smoothstep(60.,1e2,x))*(u*u*sin(y*T*f));"
       "if(v<2.)"
         "s+=u*sin(y*T*f+i)*.3*6.;"
       "else"
         "{"
           "float x=a*0.;"
           "s+=7.*u*sin(y*T*f+i+d(vec3(vec2(sin(x),cos(x)),v),1.,1.).xy*30.)/z*6.;"
         "}"
     "}"
   "s*=.14;"
   "z=44.-10.*smoothstep(30.,50.,x);"
   "for(int i=0;i<4;i++)"
     "for(float v=0.;++v<z;)"
       "{"
         "float T=x,e=d(c[i]+12.*float(p(vec3(v)).z<.1)+12.*float(p(vec3(v)*1e2).x<.1)-12.*float(p(vec3(v)).x<.5)-12.);"
         "e+=12.*float(p(vec3(v)).z<.1);"
         "e-=p(vec3(v)*4.).x*smoothstep(120.,144.,x)*1e2;"
         "if(u>340)"
           "T=y*2.;"
         "T*=f*e;"
         "vec2 m=d(vec3(fract(T/f))*vec3(2,-3,-8),.5,.4).xy*r(v*.2)-d(vec3(vec2(sin(T),cos(T)),v*.1+float(i)),.5,smoothstep(120.,144.,x)*2.).xy*r(-v*.5);"
         "s+=m/z*.15*smoothstep(60.,1e2,x)*5.*smoothstep(250.,230.,u);"
       "}"
   "n=vec2(0);"
   "z=4.;"
   "for(float i=0.;++i<z;)"
     "{"
       "float T=x,u=.5+sin(T*.5)*2./T,s=mod(T,u),p=d(c[0]-12.-12.-12.),a=smoothstep(160.,180.,x);"
       "s=smoothstep(0.,.04,s)*exp(-s*(20.-15.*a))*smoothstep(u,0.,s);"
       "u=s*s*sin(y*(p*(1.+a*10.*floor(v(floor(T/u)).x*10.)))*f)*(1.-.9*a);"
       "s*=smoothstep(1e2,110.,x);"
       "if(x>60&&x<70.)"
         "s=exp(-x+60.)*4.;"
       "if(x>80&&T<1e2)"
         "s=exp(-mod(x,4.))*.4;"
       "s*=1.+0.*smoothstep(140.,150.,x);"
       "n+=s*sin(y*p*f+u)/z*3.;"
     "}"
   "s=clamp(tanh((s+n)*1.2*smoothstep(0.,5.,u))*2.,-1.,1.);"
   "i[T+3000000]=s*e+tanh(l*m*.2+sin(f*30.*u)*10.*pow(m,30.));"
 "}";

static const char* post_frag =
 "#version 460 core\n"
 "layout(location=0) uniform int F;"
 "layout(location=1) uniform float T;"
 "layout(location=2) uniform vec2 R;"
 "layout(std430,binding=0) coherent buffer Aa{uint u[];};"
 "out vec4 C;"
 "uint x;"
 "uint m(uint f)"
 "{"
   "f=(f^f>>16)*2146121005u;"
   "f=(f^f>>15)*2221713035u;"
   "return f^f>>16;"
 "}"
 "float c(float f)"
 "{"
   "return float(m(uint(f)))/float(-1u);"
 "}"
 "float c()"
 "{"
   "uint f=m(x);"
   "x=f;"
   "return float(f)/float(-1u);"
 "}"
 "uint w(ivec2 f)"
 "{"
   "return(f.x+uint(R.x)*f.y+uint(R.x*R.y))%uint(R.x*R.y);"
 "}"
 "vec3 e(float f)"
 "{"
   "vec3[4] v=vec3[](vec3(1),vec3(1,0,1),vec3(1,1,.1),vec3(.5,1,1)*1.5);"
   "return mix(v[int(f)%4],v[int(f+1)%4],smoothstep(0.,1.,fract(f)));"
 "}"
 "int[148] l=int[](-1,-1,-1,1,-1,1,1,1,-1,1,-1,-1,-1,-1,1,-1,-1,-1,-1,1,-1,1,1,1,-1,0,1,0,-1,1,-1,-1,1,1,1,-1,-1,-1,-1,1,-1,1,1,1,-1,1,-1,-1,1,1,1,-1,-1,-1,-1,1,-1,1,1,1,0,1,0,-1,-1,-1,-1,1,-1,1,1,1,-1,-1,1,-1,-1,1,-1,-1,1,0,1,-1,1,0,0,0,-1,-1,-1,1,-1,1,1,1,-1,-1,1,-1,-1,1,-1,-1,1,1,1,-1,-1,-1,-1,1,-1,1,1,1,-1,-1,1,-1,-1,0,1,0,-1,1,-1,-1,1,1,1,-1,-1,-1,-1,1,-1,0,1,-1,-1,0,1,1,-1,1,-1,-1);"
 "float c(inout vec2 f,inout float i,int u,int x)"
 "{"
   "for(int s=u;++s<x+u;)"
     "{"
       "vec2 v=vec2(l[s*4],l[s*4+1]),T=vec2(l[s*4+2],l[s*4+3]);"
       "float m=length(T-v);"
       "vec2 c=(T-v)/m;"
       "v=abs(mat2(c.x,-c.y,c.y,c.x)*(f-(v+T)*.5))-vec2(m,.2)*.5;"
       "i=min(i,length(max(v,0.))+min(max(v.x-.2,v.y),0.));"
     "}"
   "f.x-=2.5;"
   "return i;"
 "}"
 "void main()"
 "{"
   "vec2 f=gl_FragCoord.xy/R.xy;"
   "x=uint(gl_FragCoord.x+gl_FragCoord.y*1111);"
   "c();"
   "float v=smoothstep(250.,250.1,T),s=smoothstep(280.,280.1,T),i=exp(-mod(T,.5+sin(T*.5)*2./T)*40.),y=.03+.05*smoothstep(90.,190.,T)-v+4.*s*smoothstep(4.,0.,mod(T,4.));"
   "i=(smoothstep(0.,50.,T)*pow(c(floor(T)),2)+.9*smoothstep(160.,190.,T)*i)*(1.-v+s);"
   "if(T>80&&T<1e2)"
     "i=1e2*smoothstep(1.,0.,mod(T,4.));"
   "uint m=w(ivec2(gl_FragCoord.xy));"
   "vec3 p=vec3(u[m])*1e-4,a=e(p.x*115.*4.);"
   "p/=1.+p;"
   "p=c(floor(T*.8))<.7?"
     "1.-p:"
     "pow(abs(pow(step(p,vec3(.5)),vec3(.02))),vec3(.02));"
   "if(T>60&&T<65.)"
     "p=1.-p;"
   "if(abs(p.x-.1)<y)"
     "p-=a;"
   "C=vec4(pow(abs(p),vec3(4.400000044)),1);"
   "if(T>460.)"
     "u[m]=u[m]*400%10000000;"
   "else if(mod(T,9.-s*5.)<1.-float(T>460.))"
     "u[m]=0;"
   "else if(p.x<i)"
     "{"
       "ivec2 f=-ivec2(0,4);"
       "x+=F;"
       "f*=(int(c()<p.x*1111.)*2-1)*(1+5*int(c(floor(T))));"
       "f=f*(int(c(floor(T)*124.)*2.)*2-1)*(1+int(s*smoothstep(3.,0.,mod(T,4.))*20.));"
       "if(T>316&&c()>.5)"
         "f-=f;"
       "u[m]=u[w(ivec2(gl_FragCoord.xy)+f)];"
     "}"
   "else"
     " u[m]=0;"
   "if(v>.1)"
     "C=1.-C;"
   "if(T>350.)"
     "C=vec4(dot(C,C)<.5);"
   "f=(gl_FragCoord.xy-R.xy/2.)/R.y;"
   "v=1e3;"
   "f*=20.;"
   "if(T>420&&T<450)"
     "{"
       "int i=int(T)%3;"
       "if(i==0)"
         "f.x+=3.75,c(f,v,0,4),c(f,v,4,5),c(f,v,9,4),c(f,v,13,3);"
       "else if(i==1)"
         "f.x+=20./13.5-.25,c(f,v,16,6),c(f,v,22,5);"
       "else"
         " f.x+=3.75,c(f,v,27,6),c(f,v,4,5),c(f,v,0,4),c(f,v,33,4);"
       "if(v<0.)"
         "u[m]+=100000;"
     "}"
 "}";

static const char* render_comp =
 "#version 460 core\n"
 "layout(local_size_x=256,local_size_y=1,local_size_z=1)in;"
 "layout(std430,binding=0) coherent buffer Aaa{uint y[];};"
 "layout(location=1) uniform float Tt;"
 "layout(location=2) uniform vec2 R;"
 "float z;"
 "const float a=acos(-1.),g=acos(-1.)*2.;"
 "uint b;"
 "uint m(uint f)"
 "{"
   "f=(f^f>>16)*2146121005u;"
   "f=(f^f>>15)*2221713035u;"
   "return f^f>>16;"
 "}"
 "float c(float f)"
 "{"
   "return float(m(uint(f)))/float(-1u);"
 "}"
 "float c()"
 "{"
   "uint f=m(b);"
   "b=f;"
   "return float(f)/float(-1u);"
 "}"
 "vec3 h(float f)"
 "{"
   "return vec3(c(f),c(f),c(f));"
 "}"
 "vec2 d()"
 "{"
   "vec2 f=vec2(c(),c());"
   "return vec2(sin(f.x*g),cos(f.x*g))*sqrt(f.y);"
 "}\n"
 "#define pmod(p,amt)(mod((p+amt*0.5),amt)-amt*0.5)\n"
 "mat2 r(float f)"
 "{"
   "return mat2(cos(f),-sin(f),sin(f),cos(f));"
 "}"
 "float e()"
 "{"
   "return float(c()<.5)*2.-1.;"
 "}"
 "void main()"
 "{"
   "uint f=uint(gl_GlobalInvocationID.x);"
   "b=f+1111111u;"
   "z=Tt;"
   "z=mod(z,360.);"
   "float s=smoothstep(250.,250.1,z),v=.5+sin(z*.5)*2./z;"
   "v=exp(-mod(z,v)*4.);"
   "float i=smoothstep(155.,180.,z)*smoothstep(250.,245.,z),T=(.4*smoothstep(45.,15.,z)-.1*i*v*(c(z)-.5)+.4*smoothstep(314.,320.,z)*v)*(1.-s);"
   "v=2e2*smoothstep(25.,65.,z);"
   "bool x=mod(z,8.)<2.,u=c(floor(z+1555))>.5;"
   "float m=1.+.02*smoothstep(90.,150.,z)-i*.8,p=.2+.4*smoothstep(60.,80.,z)-.4*smoothstep(90.,110.,z)-.4*smoothstep(120.,160.,z)-.2*i;"
   "i=1.-smoothstep(90.,110.,z)+smoothstep(90.,150.,z);"
   "if(z<10.)"
     "x=false;"
   "int n=30+int(v);"
   "v=z;"
   "v+=sin(v)*.8;"
   "vec3 l=vec3(0);"
   "float g=sin(z*9.)*4.*smoothstep(280.,280.1,z);"
   "vec2 C=vec2(100,0)*s*(1.-smoothstep(314.,320.,z));"
   "vec3 A=vec3(c(),c(),c()),t=h(floor(z)),F=(A.y<.5?"
     "vec3(0,-1,0):"
     "vec3(1,0,0))*m;"
   "t*=i;"
   "for(int i=0;i<n;i++)"
     "{"
       "float m=c();"
       "l+=F*(.002*(1.+20.*t.x)+sin(float(f.x))*.01);"
       "if(A.y<.5)"
         "{"
           "if(i%10==0)"
             "F+=l;"
           "if(i%50==10)"
             "F.yz*=r(.25*a*e());"
           "if(i==20+int(sin(z)*45))"
             "{"
               "F.xy*=r(.25*a*e()+z);"
               "if(t.z>.5)"
                 "l.xy*=r(t.x);"
             "}"
           "if(t.x>.7)"
             "l=l/(dot(l,l)-.1+sin(z)*.5+.5)*(1.+sin(z+sin(z)));"
         "}"
       "else if(A.y<1.)"
         "{"
           "if(i==20)"
             "F.xz*=r(.25*a);"
           "if(i%50==50+int(sin(z*.6)*45))"
             "F.yz*=r(.25*a*e()),l+=F;"
           "if(i==20+int(sin(z*.3+float(f))*25))"
             "l+=F*(1.+v),F.xy*=r(.5*a*e());"
         "}"
       "l=abs(T)>1e-4?"
         "pmod(l,3.+T):"
         "pmod(l,3.);"
       "vec3 s;"
       "{"
         "vec3 b=l;"
         "if(x)"
           "{"
             "b=sin(b*5.+z);"
             "b.xz*=r(z*2.+sin(z*2.));"
             "if(u)"
               "b=b/(dot(b,b)-.2)+.4,b/=dot(b,b)-.2,b.xz*=r(z);"
           "}"
         "else"
           " b.xz*=r(floor(c(floor(z+50))*4.)/4.*a*2.);"
         "b.z+=4.;"
         "float w=b.z;"
         "if(z<316)"
           "b/=b.z*p;"
         "b.z=w;"
         "b.x/=R.x/R.y;"
         "s=b;"
         "s.xy+=d()*abs(s.z-g)*.05*C;"
       "}"
       "vec2 b=s.xy/2.+.5;"
       "uvec2 w=uvec2(b.xy*R.xy);"
       "uint h=w.x+uint(R.x)*uint(w.y);"
       "atomicAdd(y[h],7),atomicAdd(y[h*(1+uint(t.x*6.+z)%2)%uint(R.x*R.y)],uint(111));"
     "}"
 "}";

#endif // SHADER_INCLUDES_H_
