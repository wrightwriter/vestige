// Generated with Shader Minifier 1.4.0 (https://github.com/laurentlb/Shader_Minifier/)
#ifndef SHADER_INCLUDES_H_
# define SHADER_INCLUDES_H_

static const char* music_comp =
 "#version 460 core\n"
 "layout(local_size_x=256,local_size_y=1,local_size_z=1)in;\n"
 "layout(std430,binding=0) buffer A{vec2 f[];};\n"
 "const float s=acos(-1.),v=2.*s;\n"
 "uvec3 t(uvec3 f)\n"
 "{\n"
   "f=f*1664525u+1013904223u;\n"
   "f.x+=f.y*f.z;\n"
   "f.y+=f.z*f.x;\n"
   "f.z+=f.x*f.y;\n"
   "f^=f>>16u;\n"
   "f.x+=f.y*f.z;\n"
   "f.y+=f.z*f.x;\n"
   "f.z+=f.x*f.y;\n"
   "return f;\n"
 "}\n"
 "vec3 p(vec3 f)\n"
 "{\n"
   "uvec3 v=t(floatBitsToUint(f*125.12));\n"
   "return vec3(v)/float(-1u);\n"
 "}\n"
 "vec3 n(vec3 f)\n"
 "{\n"
   "f+=12.124;\n"
   "uvec3 v=floatBitsToUint(f);\n"
   "v=(v>>16u^v.yzx)*1111111111u;\n"
   "v=(v>>16u^v.yzx)*1111111111u;\n"
   "v=(v>>16u^v.yzx)*1111111111u;\n"
   "return vec3(v)/float(-1u);\n"
 "}\n"
 "vec3 d(float f)\n"
 "{\n"
   "return n(vec3(f));\n"
 "}\n"
 "float r(float f)\n"
 "{\n"
   "return 440.*pow(2.,f/12.);\n"
 "}\n"
 "mat2 m(float f)\n"
 "{\n"
   "return mat2(cos(f),-sin(f),sin(f),cos(f));\n"
 "}\n"
 "vec3 d(vec3 f,float v,float u)\n"
 "{\n"
   "vec4 T=vec4(0);\n"
   "for(int i=0;i++<5;)\n"
     "f.yz*=m(4.5),f.xy*=m(1.5),f+=sin(f.zxy),T=(T+vec4(cross(cos(f),sin(f.yzx)),1))/v,f*=u;\n"
   "return T.xyz/T.w;\n"
 "}\n"
 "void main()\n"
 "{\n"
   "uint T=gl_GlobalInvocationID.x;\n"
   "vec2 i=vec2(0);\n"
   "float x=float(T)/44100.,s=x,u=float(T%264600)/44100.;\n"
   "if(x>280.)\n"
     "{\n"
       "float f=exp(-mod(x,4.)*10.);\n"
       "i+=f*sin(u*30.*v+sin(u*30.*v*10.)*f*.2)*4.;\n"
     "}\n"
   "float n=1.;\n"
   "if(x>250.)\n"
     "{\n"
       "float f=2.+sin(x)*2e-4;\n"
       "x*=4.;\n"
       "float v=floor(-x/f),m=mod(-x,f);\n"
       "x=m+d(v).x*4.+(x/4.-260.)*.6;\n"
       "n=smoothstep(0.,f*.04,m)*smoothstep(f,f*.98,m)*4.;\n"
       "u*=.25+.25*float(s>260.)+d(v).z*.02;\n"
     "}\n"
   "else\n"
     " x=mix(x,0.,pow(clamp((x-230.)*.04,0.,1.),2.));\n"
   "float z=4e2;\n"
   "float[4] c=float[](-12.,1.,3.,10.);\n"
   "z=1e3;\n"
   "{\n"
     "float[7] R=float[](0.,1.,3.,5.,7.,8.,10.);\n"
     "for(float f=10.;f++<2435.+min(x,0);)\n"
       "{\n"
         "float s=60./140.*4.,T=x;\n"
         "T-=s*floor(d(f).z*4.);\n"
         "T-=s*pow(d(f).y,1.2)*(1.+6.*smoothstep(10.,20.,x));\n"
         "float c=floor(T/(s*4.)),z=smoothstep(0.,4.,c)*.5;\n"
         "T=mod(T,s*4.);\n"
         "z=r(R[int(f+c)%R.length()]-12.+12.*float(d(f+c).y<.4*z)+12.*float(d(f+c).x<.4*z)-12.*float(d(f+c).z<.5*z)-12.*float(d(f*1.5+c).z<.5*z)-12.*float(d(f*1.25+c).z<.2*z));\n"
         "float y=2.+pow(d(f+c).x,2.5)*20.;\n"
         "for(float p=0.;p<y+min(x,0);p++)\n"
           "{\n"
             "float r=1.+smoothstep(0.,4.,c)*2.*exp(-mod(x,1.))*smoothstep(0.,.004,mod(T,1.)),l=pow(d(f+p*1.5+c).x,2.+.5*smoothstep(5e2,2e3,z));\n"
             "z*=1.+floor(l*r);\n"
             "z+=(d(p+f*1.4).x-.5)*20.*smoothstep(0.,30.,x);\n"
             "r=exp(-T*(7.-6.*smoothstep(2e3,8e2,z))*.7)*smoothstep(s*2.,0.,T)*smoothstep(0.,.002,T)*smoothstep(7e3,8e2,z);\n"
             "vec2 n=vec2(sin(v*z*u+sin(d(f*2.4+c).x*15.*u)*4.*smoothstep(10.,20.,x)+sin(v*z*u*2.)*r*r*r*.6*smoothstep(20.,60.,x)))*m(f);\n"
             "i+=r*n/2425./y*200.3*float(x<60.);\n"
           "}\n"
       "}\n"
   "}\n"
   "z=4e2;\n"
   "for(float f=0.;++f<z;)\n"
     "{\n"
       "float T=x-pow(smoothstep(0.,1.,p(vec3(f)).x),1.2)*(.2+3.*p(vec3(f)).y);\n"
       "if(f<2.)\n"
         "T=x;\n"
       "float[4] m=float[](c[0],c[1],c[2],c[3]);\n"
       "if(mod(T,8)<1.)\n"
         "for(int f=0;f<4;f++)\n"
           "m[f]+=7;\n"
       "float s=mix(10.,.5+sin(T*.5)*2./T*smoothstep(10.,20.,x),smoothstep(0.,60.,x)),y=floor(T/s),a=mod(T,s);\n"
       "s=m[int(mod(y,4.))]-12.*float(p(vec3(y)).x<.2)+12.*float(p(vec3(y)).z<.2);\n"
       "s=r(s+12.*float(T>60.)-12.-12.);\n"
       "s-=12.*float(p(vec3(y)).x<.2);\n"
       "y=smoothstep(0.,.004,a)*exp(-a*10.);\n"
       "T=(2.+10.*smoothstep(60.,1e2,x))*(y*y*sin(u*s*v));\n"
       "if(f<2.)\n"
         "i+=y*sin(u*s*v+T)*.3*6.;\n"
       "else\n"
         "{\n"
           "float x=a*0.;\n"
           "i+=7.*y*sin(u*s*v+T+d(vec3(vec2(sin(x),cos(x)),f),1.,1.).xy*30.)/z*6.;\n"
         "}\n"
     "}\n"
   "i*=.14;\n"
   "z=44.-10.*smoothstep(30.,50.,x);\n"
   "for(int f=0;f<4;f++)\n"
     "for(float T=0.;++T<z;)\n"
       "{\n"
         "float y=x,n=r(c[f]+12.*float(p(vec3(T)).z<.1)+12.*float(p(vec3(T)*1e2).x<.1)-12.*float(p(vec3(T)).x<.5)-12.);\n"
         "n+=12.*float(p(vec3(T)).z<.1);\n"
         "n-=p(vec3(T)*4.).x*smoothstep(120.,144.,x)*1e2;\n"
         "if(s>340)\n"
           "y=u*2.;\n"
         "y*=v*n;\n"
         "vec2 a=d(vec3(fract(y/v))*vec3(2,-3,-8),.5,.4).xy*m(T*.2)-d(vec3(vec2(sin(y),cos(y)),T*.1+float(f)),.5,smoothstep(120.,144.,x)*2.).xy*m(-T*.5);\n"
         "i+=a/z*.15*smoothstep(60.,1e2,x);\n"
       "}\n"
   "vec2 y=vec2(0);\n"
   "z=4.;\n"
   "for(float f=0.;++f<z;)\n"
     "{\n"
       "float T=x,s=.5+sin(T*.5)*2./T,i=mod(T,s),p=r(c[0]-12.-12.-12.),m=smoothstep(160.,180.,x);\n"
       "i=smoothstep(0.,.04,i)*exp(-i*(20.-15.*m))*smoothstep(s,0.,i);\n"
       "s=i*i*sin(u*(p*(1.+m*10.*floor(d(floor(T/s)).x*10.)))*v)*(1.-.9*m);\n"
       "i*=smoothstep(1e2,110.,x);\n"
       "if(x>60&&x<70.)\n"
         "i=exp(-x+60.)*4.;\n"
       "if(x>80&&T<1e2)\n"
         "i=exp(-mod(x,4.))*.4;\n"
       "i*=1.+0.*smoothstep(140.,150.,x);\n"
       "y+=i*sin(u*p*v+s)/z*2.;\n"
     "}\n"
   "i=clamp(tanh((i+y)*1.2)*2.,-1.,1.);\n"
   "f[T+3000000]=i*n;\n"
 "}";

static const char* post_frag =
 "#version 460 core\n"
 "layout(location=0) uniform int F;\n"
 "layout(location=1) uniform float T;\n"
 "layout(location=2) uniform vec2 R;\n"
 "layout(std430,binding=0) coherent buffer Aa{uint i[];};\n"
 "out vec4 C;\n"
 "uint x=111425u;\n"
 "uint u(uint f)\n"
 "{\n"
   "f=(f^f>>16)*2146121005u;\n"
   "f=(f^f>>15)*2221713035u;\n"
   "return f^f>>16;\n"
 "}\n"
 "float c(float f)\n"
 "{\n"
   "return float(u(uint(f)))/float(-1u);\n"
 "}\n"
 "float c()\n"
 "{\n"
   "uint f=u(x);\n"
   "x=f;\n"
   "return float(f)/float(-1u);\n"
 "}\n"
 "uint w(ivec2 f)\n"
 "{\n"
   "return(f.x+uint(R.x)*f.y+uint(R.x*R.y))%uint(R.x*R.y);\n"
 "}\n"
 "vec3[4] y=vec3[](vec3(1),vec3(1,0,1),vec3(1,1,.1),vec3(.5,1,1)*1.5);\n"
 "vec3 a(float f)\n"
 "{\n"
   "int T=int(f*float(4));\n"
   "f=smoothstep(0.,1.,fract(f*float(4)));\n"
   "return mix(y[T],y[(T+1)%4],f);\n"
 "}\n"
 "void main()\n"
 "{\n"
   "x=uint(gl_FragCoord.x+gl_FragCoord.y*1111);\n"
   "c();\n"
   "float f=smoothstep(250.,250.1,T),s=smoothstep(280.,280.1,T),v=exp(-mod(T,.5+sin(T*.5)*2./T)*40.);\n"
   "v=.03+.1*smoothstep(90.,190.,T)-f+4.*s*smoothstep(4.,0.,mod(T,4.));\n"
   "float y=smoothstep(0.,50.,T)*pow(c(floor(T)),2)*(1.-f+s);\n"
   "if(T>80&&T<1e2)\n"
     "y=1e2*smoothstep(1.,0.,mod(T,4.));\n"
   "uint n=w(ivec2(gl_FragCoord.xy));\n"
   "vec3 u=vec3(i[n])*1e-4,m=a(mod(u.x*115.,1.));\n"
   "u/=1.+u;\n"
   "u=c(floor(T*.8))<.7?\n"
     "1.-u:\n"
     "pow(abs(pow(step(u,vec3(.5)),vec3(.02))),vec3(.02));\n"
   "if(T>60&&T<65.)\n"
     "u=1.-u;\n"
   "if(abs(u.x-.1)<v)\n"
     "u-=m;\n"
   "C=vec4(pow(abs(u),vec3(4.400000044)),1);\n"
   "if(mod(T,9.-s*5.)<1.)\n"
     "i[n]=0;\n"
   "else if(u.x<y)\n"
     "{\n"
       "ivec2 f=-ivec2(0,4);\n"
       "f*=(int(c()<u.x*1111.)*2-1)*(1+5*int(c(floor(T))));\n"
       "f=f*(int(c(floor(T)*124.)*2.)*2-1)*(1+int(s*smoothstep(3.,0.,mod(T,4.))*20.));\n"
       "if(T>122)\n"
         "f=ivec2(f.y,f.x);\n"
       "if(T>316&&c()>.5)\n"
         "f-=f;\n"
       "i[n]=i[w(ivec2(gl_FragCoord.xy)+f)];\n"
     "}\n"
   "else\n"
     " i[n]=0;\n"
   "if(f>.1)\n"
     "C=1.-C;\n"
   "if(T>350.)\n"
     "C=vec4(dot(C,C)<.5);\n"
 "}";

static const char* render_comp =
 "#version 460 core\n"
 "layout(local_size_x=256,local_size_y=1,local_size_z=1)in;\n"
 "layout(std430,binding=0) coherent buffer Aaa{uint l[];};\n"
 "layout(location=1) uniform float Tt;\n"
 "layout(location=2) uniform vec2 R;\n"
 "float z;\n"
 "const float A=acos(-1.),b=acos(-1.)*2.;\n"
 "uint g=111425u;\n"
 "uint u(uint f)\n"
 "{\n"
   "f=(f^f>>16)*2146121005u;\n"
   "f=(f^f>>15)*2221713035u;\n"
   "return f^f>>16;\n"
 "}\n"
 "float c(float f)\n"
 "{\n"
   "return float(u(uint(f)))/float(-1u);\n"
 "}\n"
 "float c()\n"
 "{\n"
   "uint f=u(g);\n"
   "g=f;\n"
   "return float(f)/float(-1u);\n"
 "}\n"
 "vec3 e(float f)\n"
 "{\n"
   "return vec3(c(f),c(f),c(f));\n"
 "}\n"
 "vec2 a()\n"
 "{\n"
   "vec2 f=vec2(c(),c());\n"
   "return vec2(sin(f.x*b),cos(f.x*b))*sqrt(f.y);\n"
 "}\n"
 "#define pmod(p,amt)(mod((p+amt*0.5),amt)-amt*0.5)\n"
 "mat2 m(float f)\n"
 "{\n"
   "return mat2(cos(f),-sin(f),sin(f),cos(f));\n"
 "}\n"
 "float d()\n"
 "{\n"
   "return float(c()<.5)*2.-1.;\n"
 "}\n"
 "void main()\n"
 "{\n"
   "uint f=uint(gl_GlobalInvocationID.x);\n"
   "g=f+1111111u;\n"
   "z=Tt;\n"
   "z=mod(z,360.);\n"
   "float s=smoothstep(250.,250.1,z),T=.5+sin(z*.5)*2./z;\n"
   "T=exp(-mod(z,T)*4.);\n"
   "T=(.4*smoothstep(45.,15.,z)-.4*smoothstep(160.,180.,z)*T+.4*smoothstep(314.,320.,z)*T)*(1.-s);\n"
   "float i=2e2*smoothstep(25.,65.,z);\n"
   "bool x=mod(z,8.)<2.,v=c(floor(z+1555))>.5;\n"
   "float u=1.+.02*smoothstep(90.,150.,z),n=.2+.4*smoothstep(60.,80.,z)-.4*smoothstep(90.,110.,z)-.4*smoothstep(120.,160.,z),y=1.-smoothstep(90.,110.,z)+smoothstep(90.,150.,z);\n"
   "if(z<10.)\n"
     "x=false;\n"
   "int C=30+int(i);\n"
   "i=z;\n"
   "i+=sin(i)*.8;\n"
   "vec3 p=vec3(0);\n"
   "float b=sin(z*9.)*4.*smoothstep(280.,280.1,z);\n"
   "vec2 r=vec2(100,0)*s*(1.-smoothstep(314.,320.,z));\n"
   "vec3 D=vec3(c(),c(),c()),t=e(floor(z)),w=(D.y<.5?\n"
     "vec3(0,-1,0):\n"
     "vec3(1,0,0))*u;\n"
   "t*=y;\n"
   "for(int u=0;u<C;u++)\n"
     "{\n"
       "float y=c();\n"
       "p+=w*(.002*(1.+20.*t.x)+sin(float(f.x))*.01);\n"
       "if(D.y<.5)\n"
         "{\n"
           "if(u%10==0)\n"
             "w+=p;\n"
           "if(u%50==10)\n"
             "w.yz*=m(.25*A*d());\n"
           "if(u==20+int(sin(z)*45))\n"
             "{\n"
               "w.xy*=m(.25*A*d()+z);\n"
               "if(t.z>.5)\n"
                 "p.xy*=m(t.x);\n"
             "}\n"
           "if(t.x>.7)\n"
             "p=p/(dot(p,p)-.1+sin(z)*.5+.5)*(1.+sin(z+sin(z)));\n"
         "}\n"
       "else if(D.y<1.)\n"
         "{\n"
           "if(u==20)\n"
             "w.xz*=m(.25*A);\n"
           "if(u%50==50+int(sin(z*.6)*45))\n"
             "w.yz*=m(.25*A*d()),p+=w;\n"
           "if(u==20+int(sin(z*.3+float(f))*25))\n"
             "p+=w*(1.+i),w.xy*=m(.5*A*d());\n"
         "}\n"
       "p=abs(T)>1e-4?\n"
         "pmod(p,3.+T):\n"
         "pmod(p,3.);\n"
       "vec3 s;\n"
       "{\n"
         "vec3 g=p;\n"
         "if(x)\n"
           "{\n"
             "g=sin(g*5.+z);\n"
             "g.xz*=m(z*2.+sin(z*2.));\n"
             "if(v)\n"
               "g=g/(dot(g,g)-.2)+.4,g/=dot(g,g)-.2,g.xz*=m(z);\n"
           "}\n"
         "else\n"
           " g.xz*=m(floor(c(floor(z+50))*4.)/4.*A*2.);\n"
         "g.z+=4.;\n"
         "float e=g.z;\n"
         "if(z<316)\n"
           "g/=g.z*n;\n"
         "g.z=e;\n"
         "g.x/=R.x/R.y;\n"
         "s=g;\n"
         "s.xy+=a()*abs(s.z-b)*.05*r;\n"
       "}\n"
       "vec2 g=s.xy/2.+.5;\n"
       "uvec2 e=uvec2(g.xy*R.xy);\n"
       "uint F=e.x+uint(R.x)*uint(e.y);\n"
       "atomicAdd(l[F],7),atomicAdd(l[F*(1+uint(t.x*6.+z)%2)%uint(R.x*R.y)],uint(111));\n"
     "}\n"
 "}";

#endif // SHADER_INCLUDES_H_
